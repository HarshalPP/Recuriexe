// const credentials = require('../../../../credential.json');
const pdModel = require('../model/credit.Pd.model.js')
const credentials = require("../../../../liveSheet.json");
const { google } = require("googleapis");
const { GoogleAuth } = require("google-auth-library");
const moment = require('moment');
const {
  success,
  unknownError,
  serverValidation,
  unauthorized,
  badRequest,
  notFound,
} = require("../../../../globalHelper/response.globalHelper");

const newBranchModel = require('../model/adminMaster/newBranch.model.js')
const customerModel = require("../model/customer.model");
const applicantModel = require("../model/applicant.model.js");
const vendorModel = require('../model/adminMaster/vendor.model.js')
const employeeModel = require('../model/adminMaster/employe.model.js')
const productModel = require("../model/adminMaster/product.model");
const cibilModel = require("../model/cibilDetail.model.js");
const externalVendorModel = require("../model/externalManager/externalVendorDynamic.model.js");
const mongoose = require("mongoose");
const creditPdSchema = require('../model/credit.Pd.model.js');
const {getAllFormattedDates} = require("../../../../Middelware/timeZone.js")
const customerDocumentModel = require("../model/customerPropertyDetail.model.js")
const ObjectId = mongoose.Types.ObjectId;
const coApplicantModel = require("../model/co-Applicant.model");


  // Google Sheets setup
  const baseUrl = "https://prod.fincooper.in";


function handleAxiosError(error) {
  if (error.response) {
    if (error.response.status === 400) {
      console.error("Bad Request (400): ", error.response.data);
    } else {
      console.error(
        `Error Response (${error.response.status}): `,
        error.response.data
      );
    }
  } else if (error.request) {
    console.error("No Response received: ", error.request);
  } else {
    console.error("Error: ", error.message);
  }
}

const customerHeaders = [
  "Customer Fin ID",
  "payment Status",
  "Employee Unique ID",
  "Employee Name",
  "Order ID",
  "Mobile Number",
  "Executive Name",
  "Branch Name",
  "Nearest Branch Name",
  "login Fees",
  "Loan Amount",
  "ROI",
  "Tenure",
  "EMI",
  "TransactionId",
  "Payment Image",
  "Created At",
  "updated At",
  "_id",
];

const leadGenerateHeaders = [
  "Employee ID",
  "employe Name",
  "user Name",
  "Employee Assgin ID",
  "lead Generated By",
  "branchName",
  "companyName",
  "Customer Name",
  "City",
  "customerMobileNo",
  "loanAmount",
  "pincode",
  "monthlyIncome",
  "loanTypeId",
  "selfieWithCustomer",
  "status",
  "remark",
  "distrctName",
  "pakkaHouse",
  "agriland",
  "otherSourceOfIncome",
  "customerFeedback",
  "updated At",
  "created At",
  "_id",
]

const applicantHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "AadharNo",
  "PanNo",
  "Full Name",
  "Spouse Name",
  "Father Name",
  "Mother Name",
  "Gender",
  "Mobile No",
  "Marital Status",
  "Email",
  "DOB",
  "Religion",
  "Caste",
  "Education",
  "Age",
  "VoterId No",
  "Driving LicenceNo",
  "Permanent Address Line1",
  "Permanent Address Line2",
  "Permanent City",
  "Permanent State",
  "Permanent District",
  "Permanent Pin Code",
  "Local Address Line1",
  "Local Address Line2",
  "Local City",
  "Local State",
  "Local District",
  "applicantPhoto",
  "Aadhar Front Image",
  "Aadhar Back Image",
  "Pan Front Image",
  "VoterId Image",
  "Driving Licence Image",
  "OCR Aadhar Front Image",
  "OCR Aadhar Back Image",
  "Created At",
  "updated At",
  "_id",
];

const coApplicantHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "AadharNo",
  "Doc Type",
  "Doc No",
  "Full Name",
  "Spouse Name",
  "Father Name",
  "Mother Name",
  "Gender",
  "Mobile No",
  "Marital Status",
  "Email",
  "DOB",
  "Religion",
  "Caste",
  "Education",
  "Age",
  "relationWithApplicant",
  "Permanent Address Line1",
  "Permanent Address Line2",
  "Permanent City",
  "Permanent State",
  "Permanent District",
  "Permanent Pin Code",
  "Local Address Line1",
  "Local Address Line2",
  "Local City",
  "Local State",
  "Local District",
  "coApplicantPhoto",
  "Aadhar Front Image",
  "Aadhar Back Image",
  "Doc Image",
  "OCR Aadhar Front Image",
  "OCR Aadhar Back Image",
  "createdAt",
  "updatedAt",
  "_id",
];

const guarantorHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "AadharNo",
  "Doc Type",
  "Doc No",
  "Full Name",
  "Spouse Name",
  "Father Name",
  "Mother Name",
  "Gender",
  "Mobile No",
  "Marital Status",
  "Email",
  "DOB",
  "Religion",
  "Caste",
  "Education",
  "Age",
  "relationWithApplicant",
  "Permanent Address Line1",
  "Permanent Address Line2",
  "Permanent City",
  "Permanent State",
  "Permanent District",
  "Permanent Pin Code",
  "Local Address Line1",
  "Local Address Line2",
  "Local City",
  "Local State",
  "Local District",
  "guarantorPhoto",
  "Aadhar Front Image",
  "Aadhar Back Image",
  "Doc Image",
  "OCR Aadhar Front Image",
  "OCR Aadhar Back Image",
  "createdAt",
  "updatedAt",
  "_id",
];

const referenceHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "Reference 1 Name",
  "Reference 1 Relation",
  "Reference 1 Address",
  "Reference 1 Mobile",
  "Reference 2 Name",
  "Reference 2 Relation",
  "Reference 2 Address",
  "Reference 2 Mobile",
  "EMPLOYE ID",
  "createdAt",
  "updatedAt",
  "_id",
];

const bankingHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "BANK ACCOUNT ID",
  "Bank Account Number",
  "Bank IFSC Number",
  "Account Holder Name",
  "Branch Name",
  "Branch Address",
  "Bank Statement",
  "createdAt",
  "updatedAt",
  "_id",
];

const salesCaseDetailHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "Employee ID",
  "Income Source Type",
  "Name Of Agri Owner",
  "Kasra Survey No",
  "Relation Of Applicant",
  "Agri Land In Bigha",
  "Address As Per Pawti",
  "Village Name",
  "District Name",
  "Agri Land Survey No",
  "Which Crop Is Planted",
  "How Much Crop Sold",
  "Doing From No Of Years (Agri)",
  "Agri Income Yearly",
  "Agriculture Photos",
  "Doing From No Of Years (Milk)",
  "No Of Cattles",
  "No Of Milk Giving Cattles",
  "Breed Of Cattles",
  "Total Milk Supply Per Day",
  "Name Of Dairy",
  "Dairy Owner Mob No",
  "Dairy Address",
  "Milk Provide From Since Year",
  "Expenses Of Milk Business",
  "Monthly Income Milk Business",
  "Milk Photos",
  "Company Name",
  "Address Of Salary Provider",
  "Mob No Of Salary Provider",
  "Doing From No Years (Salary)",
  "Salary Paid Through",
  "Monthly Net Salary",
  "Last 3 Month Salary Slip Photos",
  "Salary Credited 6 Month",
  "Bank Statement Photo",
  "Salary Photos",
  "Property Owner Name",
  "Relation With Applicant (Property)",
  "Village Name (Property)",
  "Gram Panchayat",
  "Patwari Halka No",
  "State",
  "District (Property)",
  "Tehsil",
  "House No",
  "Ward No",
  "Survey No",
  "Four Boundary East",
  "Four Boundary West",
  "Four Boundary North",
  "Four Boundary South",
  "Plot Aria",
  "Type Of Construction",
  "Land Rate Per SQFT",
  "Age Of Property",
  "Property Photos",
  "Other Photos",
  "createdAt",
  "updatedAt",
  "_id",
];

const creditAndPdHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "Resident Current Since",
  "Resident Type",
  "Family Member Name",
  "Family Member Age",
  "Family Member Relation",
  "Family Member Dependent",
  "Family Member Occupation Type",
  "Family Member Self-Employed Organization Name",
  "Family Member Self-Employed Designation",
  "Family Member Self-Employed Date of Joining",
  "Family Member Student Institution Name",
  "Income Source Type",
  "Agriculture Business Owner Name",
  "Agriculture Business Kasra Survey No",
  "Agriculture Business Relation with Applicant",
  "Agriculture Land in Bigha",
  "Agriculture Business Address as per Pawti",
  "Agriculture Business Village Name",
  "Agriculture Business District Name",
  "Agriculture Land Survey No",
  "Crop Planted",
  "Crop Sold Amount",
  "Agriculture Business Duration (Years)",
  "Agriculture Income Yearly",
  "Milk Business Duration (Years)",
  "No. of Cattles",
  "No. of Milk Giving Cattles",
  "Breed of Cattles",
  "Total Milk Supply Per Day",
  "Name of Dairy",
  "Dairy Owner Mobile No",
  "Dairy Address",
  "Milk Business Start Year",
  "Milk Business Expenses",
  "Milk Business Monthly Income",
  "Salary Income Company Name",
  "Salary Income Company Address",
  "Salary Income Provider Mobile No",
  "Salary Income Duration (Years)",
  "Salary Paid Through",
  "Monthly Net Salary",
  "Salary Credited for 6 Months",
  "Udyam Registration No",
  "Udyam Organisation Type",
  "Udyam Social Category",
  "Udyam Date of Incorporation",
  "Udyam Major Activity",
  "Udyam Date of Commencement of Production/Business",
  "Udyam Enterprise Type",
  "Udyam Classification Date",
  "Udyam Classification Year",
  "Udyam Official Address",
  "National Industry Classification Code Activity",
  "National Industry Classification Code Date",
  "National Industry Classification Code 2 Digit",
  "National Industry Classification Code 4 Digit",
  "National Industry Classification Code 5 Digit",
  "District Industry Centre Name",
  "MSME DFO",
  "Date of Udyam Registration",
  "Units Details Unit Name",
  "Units Details Flat",
  "Units Details Building",
  "Units Details Village/Town",
  "Units Details Block",
  "Units Details Road",
  "Units Details City",
  "Units Details Pin Code",
  "Units Details State",
  "Units Details District",
  "Property Owner Name",
  "Relation with Applicant",
  "Property Village Name",
  "Property Gram Panchayat",
  "Property Patwari Halka No",
  "Property State",
  "Property Tehsil",
  "Property House No",
  "Property Ward No",
  "Property Survey No",
  "Property Four Boundary (East)",
  "Property Four Boundary (West)",
  "Property Four Boundary (North)",
  "Property Four Boundary (South)",
  "Property Plot Area",
  "Property Type of Construction",
  "Property Land Rate Per Sqft",
  "Property Age",
  "Asset Name",
  "Asset Purchase Value",
  "Asset Market Value",
  "Total Purchase Value",
  "Total Market Value",
  "createdAt",
  "updatedAt",
  "_id",
];

const cibilHeaders = [
  "Customer Fin ID",
  "Customer ID",
  "_id",
  "Total Loans Numbers",
  "Applicant CIBIL Report",
  "Applicant CIBIL Score",
  "Applicant Total EMI Amount",
  "Applicant Total Overdue Amount",
  "Co-Applicant CIBIL Report",
  "Co-Applicant CIBIL Score",
  "Co-Applicant Total EMI Amount",
  "Co-Applicant Total Overdue Amount",
  "Guarantor CIBIL Report",
  "Guarantor CIBIL Score",
  "Guarantor Total EMI Amount",
  "Guarantor Total Overdue Amount",
  "CIBIL ID",
  "PD ID",
  "Created At",
  "Updated AT",
];

const externalVendorHeaders = [
  "FIN NO",
  "CUSTOMER NAME",
  "CUSTOMER FATHER NAME",
  "CUSTOMER MOBILE NO",
  "INTIATED BY",

  "RCU INTIATION DATE",
  "RCU INTIATED TO",
  "RCU TRIGGER",
  "RCU COMPLETION DATE",
  "RCU REPORT LINK",
  "RCU REMARKS",
  "RCU STATUS",

  "LEGAL INTIATION DATE",
  "LEGAL INTIATED TO",
  "LEGAL TRIGGER",
  "LEGAL COMPLETION DATE",
  "LEGAL REPORT LINK",
  "LEGAL REMARK",
  "LEGAL STATUS",

  // Technical Fields
  "TECHNICAL INTIATION DATE",
  "TECHNICAL INTIATED TO",
  "TECHNICAL TRIGGER",
  "TECHICAL COMPLETION DATE",
  "TECHNICAL REPORT LINK",
  "TECHNICAL REMARK",
  "TECHNICAL STATUS",

  // RM Fields
  "RM INTIATION DATE",
  "RM INTIATED TO",
  "RM TRIGGER",
  "RM COMPLETION DATE",
  "RM REPORT LINK",
  "RM REMARK",
  "RM STATUS",
];


let customerHeadersWritten = false;
let applicantHeadersWritten = false;
let coApplicantHeadersWritten = false;
let guarantorHeadersWritten = false;
let referenceHeadersWritten = false;
let bankingHeadersWritten = false;
let salesCaseDetailHeadersWritten = false;
let creditAndPdHeadersWritten = false;
let externalVendorHeadersWritten = false;
let cibilHeadersWritten = false;
let leadGenerateHeadersWritten = false;

async function appendHeadersIfNeeded(
  sheets,
  spreadsheetId,
  sheetName,
  headers,
  headersWritten
) {
  if (!headersWritten) {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:A1`,
    });

    if (!response.data.values || response.data.values.length === 0) {
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A1`,
        valueInputOption: "RAW",
        resource: { values: [headers] },
      });
    }

    headersWritten = true;
  }
  return headersWritten;
}

const headersMap = {
  "DEAL DETAILS": customerHeaders,
  "APPLICANT DETAILS": applicantHeaders,
  "CO-APPLICANT": coApplicantHeaders,
  GUARANTOR: guarantorHeaders,
  REFERENCE: referenceHeaders,
  BANKING: bankingHeaders,
  "SALES CASE DETAILS": salesCaseDetailHeaders,
  "CREDIT AND PD REPORT": creditAndPdHeaders,
  "CIBIL DETAIL": cibilHeaders,
  "EXTERNAL VENDOR": externalVendorHeaders,
  "LEAD GENERATE": leadGenerateHeaders,
};

async function updateOrAppendToSheet(sheets, spreadsheetId, sheetName, values) {
  try {
    // Get current data from the sheet
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A2:AAX`,
    });

    const rows = response.data.values || [];

    // Get the appropriate headers based on sheetName
    const headers = headersMap[sheetName];

    if (!headers) {
      throw new Error(`Headers not defined for sheet: ${sheetName}`);
    }

    // Find the index of '_id' in the headers
    const _idIndex = headers.indexOf("_id");
    if (_idIndex === -1) {
      throw new Error("'_id' header not found in the provided headers.");
    }
    let rowIndex = -1;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i][_idIndex] == values[0][_idIndex]) {
        rowIndex = i + 2; // +2 to account for header row and 0-based index
        break;
      }
    }

    const resource = { values };

    if (rowIndex > -1) {
      await sheets.spreadsheets.values.update({
        spreadsheetId,
        range: `${sheetName}!A${rowIndex}:AAX${rowIndex}`,
        valueInputOption: "RAW",
        resource,
      });
    } else {
      // Append new row
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A:A`,
        valueInputOption: "RAW",
        insertDataOption: "INSERT_ROWS",
        resource,
      });
    }
  } catch (error) {
    handleAxiosError(error);
  }
}



async function leadGenerateGoogleSheet(leadData) {

  console.log('lead ', leadData.employeeAssignNameStr, leadData.employeeAssignNameStr)
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });
  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });
  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "LEAD GENERATE";


  try {
    // Fetch Manager Data if available
    let managerData = null;
    if (leadData.managerId) {
      managerData = await employeeModel.findById(leadData.managerId);
    }

    // Fetch existing sheet data
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });
    let rows = response.data.values || [];

    // Add headers if sheet is empty
    if (rows.length === 0) {
      rows.push([
        "ID", "EMPLOYEE ID", "EMPLOYEE NAME", "USER NAME",
        "ASSIGN EMPLOYEE ID", "ASSIGN EMPLOYEE NAME", "BRANCH NAME", "CUSTOMER NAME",
        "CITY", "MOBILE NO", "LOAN AMOUNT", "PINCODE", "MONTHLY INCOME",
        "PRODUCT NAME", "SELFIE WITH CUSTOMER", "STATUS", "REMARK",
        "DISTRICT NAME", "PAKKA HOUSE", "AGRI LAND", "OTHER SOURCE OF INCOME",
        "CUSTOMER FEEDBACK", "DATE", "TIME", "APPROVED BY", "APPROVAL DATE", "APPROVAL TIME"
      ]);
    }

    // Extract headers and locate the ID column index
    const headers = rows[0];
    const idIndex = headers.indexOf('ID');

    if (idIndex === -1) {
      throw new Error('ID field not found in the sheet.');
    }

    // Prepare dynamic data mappings
    const currentTime = moment().tz('Asia/Kolkata');
    const approvalDate = currentTime.format("YYYY-MM-DD");
    const approvalTime = currentTime.format("hh:mm:ss A");

    const dataMappings = {
      "ID": leadData.idStr,
      "EMPLOYEE ID": leadData.employeeIdStr,
      "EMPLOYEE NAME": leadData.employeeNameStr,
      "USER NAME": leadData.employeeUserNameStr,
      // "LEAD GENERATED BY": leadData.leadGeneratedBy,
      "ASSIGN EMPLOYEE ID": leadData.employeeAssignIdStr,
      "ASSIGN EMPLOYEE NAME": leadData.employeeAssignNameStr,
      "BRANCH NAME": leadData.branchNameStr,
      "CUSTOMER NAME": leadData.customerName,
      "CITY": leadData.city,
      "MOBILE NO": leadData.customerMobileNo,
      "LOAN AMOUNT": leadData.loanAmount,
      "PINCODE": leadData.pincode,
      "MONTHLY INCOME": leadData.monthlyIncome,
      "PRODUCT NAME": leadData.productNameStr,
      "SELFIE WITH CUSTOMER": leadData.selfieWithCustomer
        ? `${process.env.BASE_URL}${leadData.selfieWithCustomer}`
        : '',
      "STATUS": leadData.status,
      "REMARK": leadData.remark,
      "DISTRICT NAME": leadData.distrctName,
      "PAKKA HOUSE": leadData.pakkaHouse,
      "AGRI LAND": leadData.agriland,
      "OTHER SOURCE OF INCOME": leadData.otherSourceOfIncome,
      "CUSTOMER FEEDBACK": leadData.customerFeedback,
      "DATE": leadData.dateStr,
      "TIME": leadData.timeStr,
      "APPROVED BY": managerData
        ? managerData.employeName || managerData.userName
        : '',
      "APPROVAL DATE": managerData ? approvalDate : '',
      "APPROVAL TIME": managerData ? approvalTime : ''
    };

    // Find existing row by ID
    const existingRowIndex = rows.findIndex(
      row => row[idIndex]?.toString() === leadData.idStr.toString()
    );

    if (existingRowIndex === -1) {
      // Add new row if ID is not found
      const newRow = headers.map(header => dataMappings[header] || '');
      rows.push(newRow);
    } else {
      // Update existing row
      headers.forEach((header, colIndex) => {
        if (dataMappings[header] !== undefined) {
          rows[existingRowIndex][colIndex] = dataMappings[header];
        }
      });
    }

    // Update sheet with new data
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows },
    });

    console.log('Google Sheet updated successfully.');
  } catch (error) {
    console.error('Error updating Google Sheet:', error.message);
    throw error;
  }
}


async function leadGenerateGoogleSheetListBatch(dataList) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });
  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });
  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "LEAD GENERATE";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });
    let rows = response.data.values || [];

    // Add headers if sheet is empty
    if (rows.length === 0) {
      rows.push([
        "ID", "EMPLOYEE ID", "EMPLOYEE NAME", "USER NAME",
        "ASSIGN EMPLOYEE ID", "ASSIGN EMPLOYEE NAME", "BRANCH NAME", "CUSTOMER NAME",
        "CITY", "MOBILE NO", "LOAN AMOUNT", "PINCODE", "MONTHLY INCOME",
        "PRODUCT NAME", "SELFIE WITH CUSTOMER", "STATUS", "REMARK",
        "DISTRICT NAME", "PAKKA HOUSE", "AGRI LAND", "OTHER SOURCE OF INCOME",
        "CUSTOMER FEEDBACK", "DATE", "TIME", "APPROVED BY", "APPROVAL DATE", "APPROVAL TIME"
      ]);
    }

    const headers = rows[0];
    const idIndex = headers.indexOf('ID');
    if (idIndex === -1) throw new Error('ID field not found in the sheet.');

    for (const leadData of dataList) {
      // Ensure all required fields exist, and provide default values where necessary
      const idStr = leadData.idStr || leadData._id || ''; // Fallback to `_id` if `idStr` is missing
      if (!idStr) {
        console.error(`Missing ID for leadData:`, leadData);
        continue; // Skip records with missing ID
      }

      const createdDate = new Date(leadData.createdAt || Date.now());
      const updatedDate = new Date(leadData.updatedAt || Date.now());
      const formattedCreatedDate = createdDate.toISOString().split('T')[0];
      const formattedUpdatedDate = updatedDate.toISOString().split('T')[0];
      const formattedCreatedTime = createdDate.toTimeString().split(' ')[0];
      const formattedUpdatedTime = updatedDate.toTimeString().split(' ')[0];

      const dataMappings = {
        "ID": idStr,
        "EMPLOYEE ID": leadData.employeeGenerateId.employeUniqueId || '',
        "EMPLOYEE NAME": leadData.employeeGenerateId.employeName || '',
        "USER NAME": leadData.employeeGenerateId.userName || '',
        "ASSIGN EMPLOYEE ID": leadData.employeeGenerateId?.userName || '',
        "ASSIGN EMPLOYEE NAME": leadData.employeeGenerateId?.employeName || '',
        "BRANCH NAME": leadData.branchId?.branch || '',
        "CUSTOMER NAME": leadData.customerName || '',
        "CITY": leadData.city || '',
        "MOBILE NO": leadData.customerMobileNo || '',
        "LOAN AMOUNT": leadData.loanAmount || '',
        "PINCODE": leadData.pincode || '',
        "MONTHLY INCOME": leadData.monthlyIncome || '',
        "PRODUCT NAME": leadData.loanTypeId?.productName || '',
        "SELFIE WITH CUSTOMER": leadData.selfieWithCustomer
          ? `${process.env.BASE_URL}${leadData.selfieWithCustomer}`
          : '',
        "STATUS": leadData.status || '',
        "REMARK": leadData.remark || '',
        "DISTRICT NAME": leadData.distrctName || '',
        "PAKKA HOUSE": leadData.pakkaHouse || '',
        "AGRI LAND": leadData.agriland || '',
        "OTHER SOURCE OF INCOME": leadData.otherSourceOfIncome || '',
        "CUSTOMER FEEDBACK": leadData.customerFeedback || '',
        "DATE": formattedCreatedDate,
        "TIME": formattedCreatedTime,
        "APPROVED BY": leadData.managerId?.employeName || '',
        "APPROVAL DATE": leadData.managerId ? formattedUpdatedDate : '', // Conditional check for managerId
        "APPROVAL TIME": leadData.managerId ? formattedUpdatedTime : ''
      };

      // Find existing row by ID
      const existingRowIndex = rows.findIndex(
        row => row[idIndex]?.toString() === idStr.toString()
      );

      if (existingRowIndex === -1) {
        // Add new row
        const newRow = headers.map(header => dataMappings[header] || '');
        rows.push(newRow);
      } else {
        // Update existing row
        headers.forEach((header, colIndex) => {
          if (dataMappings[header] !== undefined) {
            rows[existingRowIndex][colIndex] = dataMappings[header];
          }
        });
      }
    }

    // Batch update all rows
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows },
    });

    console.log('Google Sheet updated successfully for all records.');
  } catch (error) {
    console.error('Error updating Google Sheet:', error.message);
    throw error;
  }
}



async function customerGoogleSheet(data) {
  // console.log('branchName--',branchName)
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "DEAL DETAILS";
  const baseUrl = process.env.BASE_URL;

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:BH`,
    });


    let rows = response.data.values || [];
    let headers = rows[0] || [];

    // Define headers if the sheet is empty
    if (rows.length === 0) {
      headers = [
        "Customer Fin ID", "Payment Status", "Employee Unique ID", "Employee Name",
        "Order ID", "Mobile Number", "Executive Name", "Branch Name", "Nearest Branch Name",
        "Loan Amount", "ROI", "Tenure", "EMI", "TransactionId", "Payment Image",
        "Created At", "Updated At", "_id"
      ];
      rows.push(headers);
    }

    const customerFinIdIndex = headers.indexOf('Customer Fin ID');
    if (customerFinIdIndex === -1) {
      throw new Error('Customer Fin ID field not found in the sheet.');
    }

    const dataMappings = {
      "Customer Fin ID": "customerFinId",
      "Payment Status": "paymentStatus",
      "Employee Unique ID": "employeUniqueIdStr",
      "Employee Name": "executiveName",
      "Order ID": "orderId",
      "Mobile Number": "mobileNo",
      "Executive Name": "employeNameStr",
      "Branch Name": "branchNameStr",
      "Nearest Branch Name": "nearestBranchNameStr",
      "Loan Amount": "loanAmount",
      "ROI": "roi",
      "Tenure": "tenure",
      "EMI": "emi",
      "TransactionId": "transactionId",
      "Payment Image": "paymentImage",
      "Created At": "createdAt",
      "Updated At": "updatedAt",
      "_id": "_id"
    };
    //  console.log("sa",dataMappings)
    const fieldsWithBaseUrl = ['paymentImage'];

    const rowToUpdate = headers.map(header => {
      if (dataMappings[header]) {
        let value = data[dataMappings[header]] || '';
        if (fieldsWithBaseUrl.includes(dataMappings[header])) {
          value = value ? `${baseUrl}${value}` : " ";
        }

        return value;
      }
      return '';
    });

    const existingRowIndex = rows.findIndex(row => row[customerFinIdIndex] === data.customerFinId);

    if (existingRowIndex === -1) {
      // Insert new row

      // console.log(`Inserting new row for Customer Fin ID: ${data.customerFinId}`);
      rows.push(rowToUpdate);
    } else {
      // Update existing row
      // console.log(`Updating existing row for Customer Fin ID: ${data.customerFinId}`);
      rows[existingRowIndex] = rowToUpdate;
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows },
    });

    // console.log('Data saved to Google Sheets successfully');
  } catch (error) {
    console.error('Error updating Google Sheet:', error);
    throw error;
  }
}


async function customerGoogleSheetList(customers) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });
  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  customerHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "DEAL DETAILS",
    customerHeaders,
    customerHeadersWritten
  );

  const baseUrl = process.env.BASE_URL;
  const values = customers.map(customerData => [

    customerData.customerFinId,
    customerData.paymentStatus,
    customerData.employeId?.employeUniqueId ? customerData?.employeId?.employeUniqueId : '', // name
    customerData.employeId?.employeName ? customerData.employeId?.employeName : "",
    customerData.orderId ? customerData.orderId : '',
    customerData.mobileNo,
    customerData.executiveName,
    customerData.employeId?.branchId?.branch ? customerData.employeId?.branchId?.branch : '',  // name
    customerData.loanAmount,
    customerData.roi,
    customerData.tenure,
    customerData.emi,
    customerData.transactionId,
    customerData.paymentImage ? baseUrl + customerData.paymentImage : '',
    customerData.createdAt,
    customerData.updatedAt,
    customerData._id,
  ]);

  // Update or append the data to the Google Sheet
  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "DEAL DETAILS",
    values
  );
}



// async function appendHeadersIfNeeded(sheets, sheetId, sheetName, headers, headersWritten) {
//   // Implementation of checking and appending headers logic
//   // This is a placeholder; you need to implement this function or remove it if not needed
//   return headersWritten;
// }


// async function applicantGoogleSheet(updatedApplicant, customerFinId) {
//   const auth = new google.auth.GoogleAuth({
//     credentials,
//     scopes: ['https://www.googleapis.com/auth/spreadsheets'],
//   });

//   const authClient = await auth.getClient();
//   const sheets = google.sheets({ version: 'v4', auth: authClient });

//   const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
//   const sheetName = "APPLICANT DETAILS";
//   const baseUrl = process.env.BASE_URL;

//   try {
//     const response = await sheets.spreadsheets.values.get({
//       spreadsheetId,
//       range: `${sheetName}!A1:BH`,
//     });

//     let rows = response.data.values || [];
//     let headers = rows[0] || [];

//     // Define headers if the sheet is empty
//     if (rows.length === 0) {
//       headers = [
//         "Customer Fin ID", "Customer ID", "Aadhar No", "PAN No", "Full Name",
//         "Spouse Name", "Father Name", "Mother Name", "Gender", "Mobile No",
//         "Marital Status", "Email", "DOB", "Religion", "Caste", "Education",
//         "Age", "Voter ID No", "Driving Licence No",
//         "Permanent Address Line 1", "Permanent Address Line 2", "Permanent City",
//         "Permanent State", "Permanent District", "Permanent Pin Code",
//         "Local Address Line 1", "Local Address Line 2", "Local City",
//         "Local State", "Local District", "Applicant Photo",
//         "Aadhar Front Image", "Aadhar Back Image", "PAN Front Image",
//         "Voter ID Image", "Driving Licence Image", "OCR Aadhar Front Image",
//         "OCR Aadhar Back Image", "Created At", "Updated At", "_id"
//       ];
//       rows.push(headers);
//     }

//     const customerFinIdIndex = headers.indexOf('Customer Fin ID');
//     if (customerFinIdIndex === -1) {
//       throw new Error('Customer Fin ID field not found in the sheet.');
//     }

//     const dataMappings = {
//       "Customer Fin ID": () => customerFinId,
//       "Customer ID": "customerId",
//       "Aadhar No": "aadharNo",
//       "PAN No": "panNo",
//       "Full Name": "fullName",
//       "Spouse Name": "spouseName",
//       "Father Name": "fatherName",
//       "Mother Name": "motherName",
//       "Gender": "gender",
//       "Mobile No": "mobileNo",
//       "Marital Status": "maritalStatus",
//       "Email": "email",
//       "DOB": "dob",
//       "Religion": "religion",
//       "Caste": "caste",
//       "Education": "education",
//       "Age": "age",
//       "Voter ID No": "voterIdNo",
//       "Driving Licence No": "drivingLicenceNo",
//       "Permanent Address Line 1": (data) => data.permanentAddress?.addressLine1,
//       "Permanent Address Line 2": (data) => data.permanentAddress?.addressLine2,
//       "Permanent City": (data) => data.permanentAddress?.city,
//       "Permanent State": (data) => data.permanentAddress?.state,
//       "Permanent District": (data) => data.permanentAddress?.district,
//       "Permanent Pin Code": (data) => data.permanentAddress?.pinCode,
//       "Local Address Line 1": (data) => data.localAddress?.addressLine1,
//       "Local Address Line 2": (data) => data.localAddress?.addressLine2,
//       "Local City": (data) => data.localAddress?.city,
//       "Local State": (data) => data.localAddress?.state,
//       "Local District": (data) => data.localAddress?.district,
//       "Applicant Photo": (data) => data.applicantPhoto ? `${baseUrl}${data.applicantPhoto}` : "Not Upload Image",
//       "Aadhar Front Image": (data) => data.kycUpload?.aadharFrontImage ? `${baseUrl}${data.kycUpload.aadharFrontImage}` : "Not Upload Image",
//       "Aadhar Back Image": (data) => data.kycUpload?.aadharBackImage ? `${baseUrl}${data.kycUpload.aadharBackImage}` : "Not Upload Image",
//       "PAN Front Image": (data) => data.kycUpload?.panFrontImage ? `${baseUrl}${data.kycUpload.panFrontImage}` : "Not Upload Image",
//       "Voter ID Image": (data) => data.kycUpload?.voterIdImage ? `${baseUrl}${data.kycUpload.voterIdImage}` : "Not Upload Image",
//       "Driving Licence Image": (data) => data.kycUpload?.drivingLicenceImage ? `${baseUrl}${data.kycUpload.drivingLicenceImage}` : "Not Upload Image",
//       "OCR Aadhar Front Image": (data) => data.ocrAadharFrontImage ? `${baseUrl}${data.ocrAadharFrontImage}` : "Not Upload Image",
//       "OCR Aadhar Back Image": (data) => data.ocrAadharBackImage ? `${baseUrl}${data.ocrAadharBackImage}` : "Not Upload Image",
//       "Created At": "createdAt",
//       "Updated At": "updatedAt",
//       "_id": "_id"
//     };

//     const rowToUpdate = headers.map(header => {
//       if (dataMappings[header]) {
//         const mapping = dataMappings[header];
//         if (typeof mapping === 'function') {
//           return mapping(updatedApplicant);
//         } else {
//           return updatedApplicant[mapping] || '';
//         }
//       }
//       return '';
//     });

//     const existingRowIndex = rows.findIndex(row => row[customerFinIdIndex] === customerFinId);

//     if (existingRowIndex === -1) {
//       // Insert new row
//       console.log(`Inserting new row for Customer Fin ID: ${customerFinId}`);
//       rows.push(rowToUpdate);
//     } else {
//       // Update existing row
//       console.log(`Updating existing row for Customer Fin ID: ${customerFinId}`);
//       rows[existingRowIndex] = rowToUpdate;
//     }

//     await sheets.spreadsheets.values.update({
//       spreadsheetId,
//       range: `${sheetName}!A1`,
//       valueInputOption: 'RAW',
//       resource: { values: rows },
//     });

//     console.log('Applicant data saved to Google Sheets successfully');
//   } catch (error) {
//     console.error('Error updating Google Sheet for applicant:', error);
//     throw error;
//   }
// }


async function applicantGoogleSheet(updatedApplicant, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });
  applicantHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "APPLICANT DETAILS",
    applicantHeaders,
    applicantHeadersWritten
  );

  const baseUrl = process.env.BASE_URL;
  const values = [
    [
      customerFinId,
      updatedApplicant.customerId,
      updatedApplicant.aadharNo,
      updatedApplicant.panNo,
      updatedApplicant.fullName,
      updatedApplicant.spouseName,
      updatedApplicant.fatherName,
      updatedApplicant.motherName,
      updatedApplicant.gender,
      updatedApplicant.mobileNo,
      updatedApplicant.maritalStatus,
      updatedApplicant.email,
      updatedApplicant.dob,
      updatedApplicant.religion,
      updatedApplicant.caste,
      updatedApplicant.education,
      updatedApplicant.age,
      updatedApplicant.voterIdNo,
      updatedApplicant.drivingLicenceNo,
      updatedApplicant.permanentAddress.addressLine1,
      updatedApplicant.permanentAddress.addressLine2,
      updatedApplicant.permanentAddress.city,
      updatedApplicant.permanentAddress.state,
      updatedApplicant.permanentAddress.district,
      updatedApplicant.permanentAddress.pinCode,
      updatedApplicant.localAddress.addressLine1,
      updatedApplicant.localAddress.addressLine2,
      updatedApplicant.localAddress.city,
      updatedApplicant.localAddress.state,
      updatedApplicant.localAddress.district,
      updatedApplicant?.applicantPhoto
        ? `${baseUrl}${updatedApplicant.applicantPhoto}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.aadharFrontImage
        ? `${baseUrl}${updatedApplicant.kycUpload.aadharFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.aadharBackImage
        ? `${baseUrl}${updatedApplicant.kycUpload.aadharBackImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.panFrontImage
        ? `${baseUrl}${updatedApplicant.kycUpload.panFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.voterIdImage
        ? `${baseUrl}${updatedApplicant.kycUpload.voterIdImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.drivingLicenceImage
        ? `${baseUrl}${updatedApplicant.kycUpload.drivingLicenceImage}`
        : "Not Upload Image",
      updatedApplicant?.ocrAadharFrontImage
        ? `${baseUrl}${updatedApplicant.ocrAadharFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.ocrAadharBackImage
        ? `${baseUrl}${updatedApplicant.ocrAadharBackImage}`
        : "Not Upload Image",
      updatedApplicant.createdAt,
      updatedApplicant.updatedAt,
      updatedApplicant._id,
    ],
  ];

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "APPLICANT DETAILS",
    values
  );
}

async function coApplicantGoogleSheet(updatedCoApplicant, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  coApplicantHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "CO-APPLICANT",
    coApplicantHeaders,
    coApplicantHeadersWritten
  );
  const baseUrl = process.env.BASE_URL;
  const values = [
    [
      customerFinId,
      updatedCoApplicant.customerId,
      updatedCoApplicant.aadharNo,
      updatedCoApplicant.docType,
      updatedCoApplicant.docNo,
      updatedCoApplicant.fullName,
      updatedCoApplicant.spouseName,
      updatedCoApplicant.fatherName,
      updatedCoApplicant.motherName,
      updatedCoApplicant.gender,
      updatedCoApplicant.mobileNo,
      updatedCoApplicant.maritalStatus,
      updatedCoApplicant.email,
      updatedCoApplicant.dob,
      updatedCoApplicant.religion,
      updatedCoApplicant.caste,
      updatedCoApplicant.education,
      updatedCoApplicant.age,
      updatedCoApplicant.relationWithApplicant,
      updatedCoApplicant.permanentAddress.addressLine1,
      updatedCoApplicant.permanentAddress.addressLine2,
      updatedCoApplicant.permanentAddress.city,
      updatedCoApplicant.permanentAddress.state,
      updatedCoApplicant.permanentAddress.district,
      updatedCoApplicant.permanentAddress.pinCode,
      updatedCoApplicant.localAddress.addressLine1,
      updatedCoApplicant.localAddress.addressLine2,
      updatedCoApplicant.localAddress.city,
      updatedCoApplicant.localAddress.state,
      updatedCoApplicant.localAddress.district,
      updatedCoApplicant?.coApplicantPhoto
        ? `${baseUrl}${updatedCoApplicant.coApplicantPhoto}`
        : "Not Upload Image",
      updatedCoApplicant?.kycUpload?.aadharFrontImage
        ? `${baseUrl}${updatedCoApplicant.kycUpload.aadharFrontImage}`
        : "Not Upload Image",
      updatedCoApplicant?.kycUpload?.aadharBackImage
        ? `${baseUrl}${updatedCoApplicant.kycUpload.aadharBackImage}`
        : "Not Upload Image",
      updatedCoApplicant?.kycUpload?.docImage
        ? `${baseUrl}${updatedCoApplicant.kycUpload.docImage}`
        : "Not Upload Image",
      updatedCoApplicant?.ocrAadharFrontImage
        ? `${baseUrl}${updatedCoApplicant.ocrAadharFrontImage}`
        : "Not Upload Image",
      updatedCoApplicant?.ocrAadharBackImage
        ? `${baseUrl}${updatedCoApplicant.ocrAadharBackImage}`
        : "Not Upload Image",
      updatedCoApplicant.createdAt,
      updatedCoApplicant.updatedAt,
      updatedCoApplicant._id,
    ],
  ];

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "CO-APPLICANT",
    values
  );
}

async function guarantorGoogleSheet(updatedGuarantor, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  guarantorHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "GUARANTOR",
    guarantorHeaders,
    guarantorHeadersWritten
  );
  const baseUrl = process.env.BASE_URL;
  const values = [
    [
      customerFinId,
      updatedGuarantor.customerId,
      updatedGuarantor.aadharNo,
      updatedGuarantor.docType,
      updatedGuarantor.docNo,
      updatedGuarantor.fullName,
      updatedGuarantor.spouseName,
      updatedGuarantor.fatherName,
      updatedGuarantor.motherName,
      updatedGuarantor.gender,
      updatedGuarantor.mobileNo,
      updatedGuarantor.maritalStatus,
      updatedGuarantor.email,
      updatedGuarantor.dob,
      updatedGuarantor.religion,
      updatedGuarantor.caste,
      updatedGuarantor.education,
      updatedGuarantor.age,
      updatedGuarantor.relationWithApplicant,
      updatedGuarantor.permanentAddress.addressLine1,
      updatedGuarantor.permanentAddress.addressLine2,
      updatedGuarantor.permanentAddress.city,
      updatedGuarantor.permanentAddress.state,
      updatedGuarantor.permanentAddress.district,
      updatedGuarantor.permanentAddress.pinCode,
      updatedGuarantor.localAddress.addressLine1,
      updatedGuarantor.localAddress.addressLine2,
      updatedGuarantor.localAddress.city,
      updatedGuarantor.localAddress.state,
      updatedGuarantor.localAddress.district,
      updatedGuarantor?.guarantorPhoto
        ? `${baseUrl}${updatedGuarantor.guarantorPhoto}`
        : "Not Upload Image",
      updatedGuarantor?.kycUpload?.aadharFrontImage
        ? `${baseUrl}${updatedGuarantor.kycUpload.aadharFrontImage}`
        : "Not Upload Image",
      updatedGuarantor?.kycUpload?.aadharBackImage
        ? `${baseUrl}${updatedGuarantor.kycUpload.aadharBackImage}`
        : "Not Upload Image",
      updatedGuarantor?.kycUpload?.docImage
        ? `${baseUrl}${updatedGuarantor.kycUpload.docImage}`
        : "Not Upload Image",
      updatedGuarantor?.ocrAadharFrontImage
        ? `${baseUrl}${updatedGuarantor.ocrAadharFrontImage}`
        : "Not Upload Image",
      updatedGuarantor?.ocrAadharBackImage
        ? `${baseUrl}${updatedGuarantor.ocrAadharBackImage}`
        : "Not Upload Image",
      updatedGuarantor.createdAt,
      updatedGuarantor.updatedAt,
      updatedGuarantor._id,
    ],
  ];

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "GUARANTOR",
    values
  );
}

async function referenceGoogleSheet(updatedReference, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  referenceHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "REFERENCE",
    referenceHeaders,
    referenceHeadersWritten
  );

  const values = [
    [
      customerFinId,
      updatedReference.customerId,
      updatedReference.reference1.referenceName,
      updatedReference.reference1.relationWithApplicant,
      updatedReference.reference1.address,
      updatedReference.reference1.mobileNo,
      updatedReference.reference2.referenceName,
      updatedReference.reference2.relationWithApplicant,
      updatedReference.reference2.address,
      updatedReference.reference2.mobileNo,
      updatedReference.employeId,
      updatedReference.createdAt,
      updatedReference.updatedAt,
      updatedReference._id,
    ],
  ];

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "REFERENCE",
    values
  );
}

async function bankDetailGoogleSheet(bankDetailData, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const baseUrl = process.env.BASE_URL;

  // Flatten the bankDetails array into a single row with dynamic headers
  const flattenedValues = [
    customerFinId,
    bankDetailData.customerId,
    bankDetailData._id,
    bankDetailData.createdAt,
    bankDetailData.updatedAt,
  ];

  bankDetailData.bankDetails.forEach((item, index) => {
    const idx = index + 1; // To create columns like -1, -2, -3, etc.
    flattenedValues.push(
      item.bankACNumber,
      item.bankIFSCNumber,
      item.accountHolderName,
      item.branchName,
      item.branchAddress,
      item.bankStatement.map((statement) => baseUrl + statement).join(", ")
    );
  });

  // Add headers dynamically based on the number of bankDetails
  const dynamicHeaders = [
    "Customer Fin ID",
    "Customer ID",
    "_id",
    "Created At",
    "Updated At",
  ];
  bankDetailData.bankDetails.forEach((_, index) => {
    const idx = index + 1;
    dynamicHeaders.push(
      `Bank Account Number-${idx}`,
      `Bank IFSC Number-${idx}`,
      `Account Holder Name-${idx}`,
      `Branch Name-${idx}`,
      `Branch Address-${idx}`,
      `Bank Statement-${idx}`
    );
  });

  // Check if headers are already set
  const headerCheck = await sheets.spreadsheets.values.get({
    spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
    range: "BANKING!A1:Z1",
  });

  const existingHeaders = headerCheck.data.values
    ? headerCheck.data.values[0]
    : [];

  if (JSON.stringify(dynamicHeaders) !== JSON.stringify(existingHeaders)) {
    // Write new headers
    await sheets.spreadsheets.values.update({
      spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
      range: "BANKING!A1",
      valueInputOption: "RAW",
      resource: { values: [dynamicHeaders] },
    });
  }

  // Update or append the row in the sheet
  await updateOrAppendToSheet1(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "BANKING",
    [flattenedValues]
  );
}

async function updateOrAppendToSheet1(
  sheets,
  spreadsheetId,
  sheetName,
  values
) {
  try {
    // Get current data from the sheet
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A2:AAX`,
    });

    const rows = response.data.values || [];

    // Find the row index with the matching '_id'
    const _idIndex = 2; // Assuming '_id' is the 3rd column in the sheet
    let rowIndex = -1;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i][_idIndex] == values[0][_idIndex]) {
        rowIndex = i + 2; // +2 to account for header row and 0-based index
        break;
      }
    }

    const resource = { values };

    if (rowIndex > -1) {
      // Update existing row
      await sheets.spreadsheets.values.update({
        spreadsheetId,
        range: `${sheetName}!A${rowIndex}:AAX${rowIndex}`,
        valueInputOption: "RAW",
        resource,
      });
    } else {
      // Append new row
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A:A`,
        valueInputOption: "RAW",
        insertDataOption: "INSERT_ROWS",
        resource,
      });
    }
  } catch (error) {
    console.error("Error updating or appending to sheet:", error);
  }
}

async function salesCaseDetailGoogleSheet(result, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  salesCaseDetailHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "SALES CASE DETAILS",
    salesCaseDetailHeaders,
    salesCaseDetailHeadersWritten
  );

  const incomeSource = result.incomeSource[0] || {};
  const agricultureBusiness = incomeSource.agricultureBusiness || {};
  const milkBusiness = incomeSource.milkBusiness || {};
  const salaryIncome = incomeSource.salaryIncome || {};
  const property = result.property || {};
  const baseUrl = process.env.BASE_URL;
  const values = [
    [
      customerFinId,
      result.customerId,
      result.employeId,
      incomeSource.incomeSourceType,
      agricultureBusiness.nameOfAgriOwner,
      agricultureBusiness.kasraSurveyNo,
      agricultureBusiness.relationOfApplicant,
      agricultureBusiness.agriLandInBigha,
      agricultureBusiness.addressAsPerPawti,
      agricultureBusiness.villageName,
      agricultureBusiness.districtName,
      agricultureBusiness.agriLandSurveyNo,
      agricultureBusiness.whichCropIsPlanted,
      agricultureBusiness.howMuchCropSold,
      agricultureBusiness.doingFromNoOfYears,
      agricultureBusiness.agriincomeYearly,
      (agricultureBusiness.agriculturePhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
      milkBusiness.doingFromNoOfYears,
      milkBusiness.noOfCattles,
      milkBusiness.noOfMilkGivingCattles,
      milkBusiness.breedOfCattles,
      milkBusiness.totalMilkSupplyPerDay,
      milkBusiness.nameOfDairy,
      milkBusiness.dairyOwnerMobNo,
      milkBusiness.dairyAddress,
      milkBusiness.milkprovideFromSinceYear,
      milkBusiness.expensesOfMilkBusiness,
      milkBusiness.monthlyIncomeMilkBusiness,
      (milkBusiness.milkPhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
      salaryIncome.companyName,
      salaryIncome.addressOfSalaryProvider,
      salaryIncome.MobNoOfSalaryProvider,
      salaryIncome.doingFromNoYears,
      salaryIncome.salaryPaidThrouch,
      salaryIncome.monthlyNetSalary,
      (salaryIncome.last3MonthSalarySlipPhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
      salaryIncome.salaryCredited6Month,
      salaryIncome.bankStatementPhoto,
      (salaryIncome.salaryPhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
      property.propertyOwnerName,
      property.relationWithApplicant,
      property.villageName,
      property.gramPanchayat,
      property.patwariHalkaNo,
      property.state,
      property.district,
      property.tehsil,
      property.houseNo,
      property.wardNo,
      property.surveyNo,
      property.fourBoundary.east,
      property.fourBoundary.west,
      property.fourBoundary.north,
      property.fourBoundary.south,
      property.technicalValue.plotAria,
      property.technicalValue.typeOfContruction,
      property.technicalValue.landRatePerSQFT,
      property.technicalValue.ageOfProperty,
      (property.technicalValue.propertyPhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
      (property.technicalValue.otherPhotos || [])
        .map((photo) => baseUrl + photo)
        .join(", "),
    ],
  ];

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "SALES CASE DETAILS",
    values
  );
}

async function creditAndPdGoogleSheet(result) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  creditAndPdHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "CREDIT AND PD REPORT",
    creditAndPdHeaders,
    creditAndPdHeadersWritten
  );

  const values = result.incomeSource.map((incomeSource) => {
    const agricultureBusiness = incomeSource.agricultureBusiness || {};
    const milkBusiness = incomeSource.milkBusiness || {};
    const salaryIncome = incomeSource.salaryIncome || {};
    const assetDetails = result.assetDetails || [];
    const total = result.total || {};
    const baseUrl = process.env.BASE_URL;

    return [
      result.customerId,
      result.residentCurrentSince,
      result.residentType,
      result.familyMember[0]?.name,
      result.familyMember[0]?.age,
      result.familyMember[0]?.relation,
      result.familyMember[0]?.dependent,
      result.familyMember[0]?.occupationType,
      result.familyMember[0]?.selfEmployed?.nameOfOrganization,
      result.familyMember[0]?.selfEmployed?.designation,
      result.familyMember[0]?.selfEmployed?.dateOfJoining,
      result.familyMember[1]?.student?.institutionName,
      incomeSource.incomeSourceType,
      agricultureBusiness.nameOfAgriOwner,
      agricultureBusiness.kasraSurveyNo,
      agricultureBusiness.relationOfApplicant,
      agricultureBusiness.agriLandInBigha,
      agricultureBusiness.addressAsPerPawti,
      agricultureBusiness.villageName,
      agricultureBusiness.districtName,
      agricultureBusiness.agriLandSurveyNo,
      agricultureBusiness.whichCropIsPlanted,
      agricultureBusiness.howMuchCropSold,
      agricultureBusiness.doingFromNoOfYears,
      agricultureBusiness.agriincomeYearly,
      milkBusiness.doingFromNoOfYears,
      milkBusiness.noOfCattles,
      milkBusiness.noOfMilkGivingCattles,
      milkBusiness.breedOfCattles,
      milkBusiness.totalMilkSupplyPerDay,
      milkBusiness.nameOfDairy,
      milkBusiness.dairyOwnerMobNo,
      milkBusiness.dairyAddress,
      milkBusiness.milkprovideFromSinceYear,
      milkBusiness.expensesOfMilkBusiness,
      milkBusiness.monthlyIncomeMilkBusiness,
      salaryIncome.companyName,
      salaryIncome.addressOfSalaryProvider,
      salaryIncome.MobNoOfSalaryProvider,
      salaryIncome.doingFromNoYears,
      salaryIncome.salaryPaidThrouch,
      salaryIncome.monthlyNetSalary,
      salaryIncome.salaryCredited6Month,
      result.udyamBusiness.udyamRegistrationNo,
      result.udyamBusiness.organisationType,
      result.udyamBusiness.socialCategory,
      result.udyamBusiness.dateofIncorporation,
      result.udyamBusiness.majorActivity,
      result.udyamBusiness.DateofCommencementofProductionBusiness,
      result.udyamBusiness.enterpriseType,
      result.udyamBusiness.classificationDate,
      result.udyamBusiness.classificationYear,
      `${result.udyamBusiness.officialAddressOfEnterprise.FlatDoorBlockNo}, ${result.udyamBusiness.officialAddressOfEnterprise.VillageTown}, ${result.udyamBusiness.officialAddressOfEnterprise.RoadStreetLane}, ${result.udyamBusiness.officialAddressOfEnterprise.state}, ${result.udyamBusiness.officialAddressOfEnterprise.mobile}, ${result.udyamBusiness.officialAddressOfEnterprise.nameofPremisesBuilding}, ${result.udyamBusiness.officialAddressOfEnterprise.block}, ${result.udyamBusiness.officialAddressOfEnterprise.city}, ${result.udyamBusiness.officialAddressOfEnterprise.district}, ${result.udyamBusiness.officialAddressOfEnterprise.pin}`,
      result.udyamBusiness.nationalIndustryClassificationCode.activity,
      result.udyamBusiness.nationalIndustryClassificationCode.date,
      result.udyamBusiness.nationalIndustryClassificationCode.nic2Digit,
      result.udyamBusiness.nationalIndustryClassificationCode.nic4Digit,
      result.udyamBusiness.nationalIndustryClassificationCode.nic5Digit,
      result.udyamBusiness.nationalIndustryClassificationCode.dicName,
      result.udyamBusiness.nationalIndustryClassificationCode.msmeDFO,
      result.udyamBusiness.nationalIndustryClassificationCode
        .DateofUdyamRegistration,
      result.udyamBusiness.unitsDetails.unitName,
      result.udyamBusiness.unitsDetails.flat,
      result.udyamBusiness.unitsDetails.building,
      result.udyamBusiness.unitsDetails.VillageTown,
      result.udyamBusiness.unitsDetails.block,
      result.udyamBusiness.unitsDetails.road,
      result.udyamBusiness.unitsDetails.city,
      result.udyamBusiness.unitsDetails.pin,
      result.udyamBusiness.unitsDetails.state,
      result.udyamBusiness.unitsDetails.district,
      result.property.propertyOwnerName,
      result.property.relationWithApplicant,
      result.property.villageName,
      result.property.gramPanchayat,
      result.property.patwariHalkaNo,
      result.property.state,
      result.property.tehsil,
      result.property.houseNo,
      result.property.wardNo,
      result.property.surveyNo,
      result.property.fourBoundary.east,
      result.property.fourBoundary.west,
      result.property.fourBoundary.north,
      result.property.fourBoundary.south,
      result.property.technicalValue.plotAria,
      result.property.technicalValue.typeOfContruction,
      result.property.technicalValue.landRatePerSQFT,
      result.property.technicalValue.ageOfProperty,
      assetDetails.map((asset) => asset.assetName).join(", "),
      assetDetails.map((asset) => asset.purchaseValue).join(", "),
      assetDetails.map((asset) => asset.marketValue).join(", "),
      total.totalPurchaseValue,
      total.totalMarketValue,
    ];
  });

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "CREDIT AND PD REPORT",
    values
  );
}

async function cibilDetailGoogleSheet(updatedCibilData, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });
  console.log("sgar", customerFinId)
  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });
  cibilHeadersWritten = await appendHeadersIfNeeded(sheets, process.env.GOOGLE_SHEET_KEY_LIVE, 'CIBIL DETAIL', cibilHeaders, cibilHeadersWritten);

  const values = [
    [customerFinId,
      updatedCibilData.customerId,
      updatedCibilData.TotalLoansNumbers,
      updatedCibilData.applicantCibilReport,
      updatedCibilData.applicantCibilScore,
      updatedCibilData.applicantTotalEmiAmount,
      updatedCibilData.applicantTotalOverDueAmount,
      updatedCibilData.coApplicantCibilReport,
      updatedCibilData.coApplicantCibilScore,
      updatedCibilData.coApplicantTotalEmiAmount,
      updatedCibilData.coApplicantTotalOverDueAmount,
      updatedCibilData.guarantorCibilReport,
      updatedCibilData.guarantorCibilScore,
      updatedCibilData.guarantorTotalEmiAmount,
      updatedCibilData.guarantorTotalOverDueAmount,
      updatedCibilData.cibilId,
      updatedCibilData.pdId,
      updatedCibilData.createdAt,
      updatedCibilData.updatedAt,
      updatedCibilData._id,

      updatedCibilData.applicantCibilDetail.map((detail) => [
        detail.loanType,
        detail.loanAmount,
        detail.outstandingAmount,
        detail.overDue,
        detail.emi,
      ]),

      updatedCibilData.coApplicantCibilDetail.map((detail) => [
        detail.loanType,
        detail.loanAmount,
        detail.outstandingAmount,
        detail.overDue,
        detail.emi,
      ]),

      updatedCibilData.guarantorCibilDetail.map((detail) => [
        detail.loanType,
        detail.loanAmount,
        detail.outstandingAmount,
        detail.overDue,
        detail.emi,
      ])
    ],
  ];

  await updateOrAppendToSheet(sheets, process.env.GOOGLE_SHEET_KEY_LIVE, 'CIBIL DETAIL', values);
}

async function cibilDetailGoogleSheet(updatedCibilData, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });

  const baseUrl = process.env.BASE_URL;

  // Initialize headers and flag for checking if headers are written
  let cibilHeadersWritten = false;
  const cibilHeaders = [
    'Customer Fin ID', 'Customer ID', '_id', 'Total Loans Numbers', 'Applicant CIBIL Report',
    'Applicant CIBIL Score', 'Applicant Total EMI Amount', 'Applicant Total OverDue Amount',
    'Co-Applicant CIBIL Report', 'Co-Applicant CIBIL Score', 'Co-Applicant Total EMI Amount',
    'Co-Applicant Total OverDue Amount', 'Guarantor CIBIL Report', 'Guarantor CIBIL Score',
    'Guarantor Total EMI Amount', 'Guarantor Total OverDue Amount', 'CIBIL ID', 'PD ID',
    'Created At', 'Updated At',
  ];

  // Flatten the cibil details into a single row with dynamic headers
  const flattenedValues = [
    customerFinId,
    updatedCibilData.customerId,
    updatedCibilData._id,
    updatedCibilData.TotalLoansNumbers,
    updatedCibilData.applicantCibilReport,
    updatedCibilData.applicantCibilScore,
    updatedCibilData.applicantTotalEmiAmount,
    updatedCibilData.applicantTotalOverDueAmount,
    updatedCibilData.coApplicantCibilReport,
    updatedCibilData.coApplicantCibilScore,
    updatedCibilData.coApplicantTotalEmiAmount,
    updatedCibilData.coApplicantTotalOverDueAmount,
    updatedCibilData.guarantorCibilReport,
    updatedCibilData.guarantorCibilScore,
    updatedCibilData.guarantorTotalEmiAmount,
    updatedCibilData.guarantorTotalOverDueAmount,
    updatedCibilData.cibilId,
    updatedCibilData.pdId,
    updatedCibilData.createdAt,
    updatedCibilData.updatedAt,
  ];

  // Add applicant details dynamically
  updatedCibilData.applicantCibilDetail.forEach((detail, index) => {
    const idx = index + 1;
    flattenedValues.push(
      detail.loanType,
      detail.loanAmount,
      detail.outstandingAmount,
      detail.overDue,
      detail.emi
    );
    cibilHeaders.push(
      `Applicant Loan Type-${idx}`,
      `Applicant Loan Amount-${idx}`,
      `Applicant Outstanding Amount-${idx}`,
      `Applicant OverDue-${idx}`,
      `Applicant EMI-${idx}`
    );
  });

  // Add co-applicant details dynamically
  updatedCibilData.coApplicantCibilDetail.forEach((detail, index) => {
    const idx = index + 1;
    flattenedValues.push(
      detail.loanType,
      detail.loanAmount,
      detail.outstandingAmount,
      detail.overDue,
      detail.emi
    );
    cibilHeaders.push(
      `Co-Applicant Loan Type-${idx}`,
      `Co-Applicant Loan Amount-${idx}`,
      `Co-Applicant Outstanding Amount-${idx}`,
      `Co-Applicant OverDue-${idx}`,
      `Co-Applicant EMI-${idx}`
    );
  });

  // Add guarantor details dynamically
  updatedCibilData.guarantorCibilDetail.forEach((detail, index) => {
    const idx = index + 1;
    flattenedValues.push(
      detail.loanType,
      detail.loanAmount,
      detail.outstandingAmount,
      detail.overDue,
      detail.emi
    );
    cibilHeaders.push(
      `Guarantor Loan Type-${idx}`,
      `Guarantor Loan Amount-${idx}`,
      `Guarantor Outstanding Amount-${idx}`,
      `Guarantor OverDue-${idx}`,
      `Guarantor EMI-${idx}`
    );
  });

  // Check if headers are already set
  const headerCheck = await sheets.spreadsheets.values.get({
    spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
    range: 'CIBIL DETAIL!A1:Z1',
  });

  const existingHeaders = headerCheck.data.values ? headerCheck.data.values[0] : [];

  if (JSON.stringify(cibilHeaders) !== JSON.stringify(existingHeaders)) {
    // Write new headers if needed
    await sheets.spreadsheets.values.update({
      spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
      range: 'CIBIL DETAIL!A1',
      valueInputOption: 'RAW',
      resource: { values: [cibilHeaders] },
    });
  }

  // Update or append the row in the sheet
  await updateOrAppendToSheet1(sheets, process.env.GOOGLE_SHEET_KEY_LIVE, 'CIBIL DETAIL', [flattenedValues]);
}

// async function externalVendorGoogleSheet(externalVendorData) {
//   const auth = new google.auth.GoogleAuth({
//     credentials,
//     scopes: ['https://www.googleapis.com/auth/spreadsheets'],
//   });

//   const authClient = await auth.getClient();
//   const sheets = google.sheets({ version: 'v4', auth: authClient });

//   const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
//   const sheetName = "EXTERNAL VENDOR";

//   try {
//     const response = await sheets.spreadsheets.values.get({
//       spreadsheetId,
//       range: `${sheetName}!A1:EZ`,
//     });

//     let rows = response.data.values || [];
//     let headers = rows[0] || [];

//     const externalVendorHeaders = [
//       "FIN NO", "CUSTOMER NAME", "CUSTOMER FATHER NAME", "CUSTOMER MOBILE NO", "INTIATED BY",
//       "RCU INTIATION DATE", "RCU INTIATED TO", "RCU TRIGGER",
//       "RCU COMPLETION DATE", "RCU REPORT LINK", "RCU REMARKS", "RCU STATUS",
//       "LEGAL INTIATION DATE", "LEGAL INTIATED TO", "LEGAL TRIGGER",
//       "LEGAL COMPLETION DATE", "LEGAL REPORT LINK", "LEGAL REMARK", "LEGAL STATUS",
//       "TECHNICAL INTIATION DATE", "TECHNICAL INTIATED TO", "TECHNICAL TRIGGER",
//       "TECHICAL COMPLETION DATE", "TECHNICAL REPORT LINK", "TECHNICAL REMARK", "TECHNICAL STATUS",
//       "RM INTIATION DATE", "RM INTIATED TO", "RM TRIGGER",
//       "RM COMPLETION DATE", "RM REPORT LINK", "RM REMARK", "RM STATUS"
//     ];

//     if (rows.length === 0) {
//       headers = externalVendorHeaders;
//       rows.push(headers);
//     }

//     const customerIdIndex = headers.indexOf('FIN NO');
//     console.log('FIN NO--',customerIdIndex)
//     if (customerIdIndex === -1) {
//       throw new Error('FIN NO field not found in the sheet.');
//     }

//     const existingRowIndex = rows.findIndex(row =>
//       row[customerIdIndex] === (externalVendorData.customerFinIdStr|| '')
//     );

//     // Helper functions
//     const formatDate = (date) => {
//       if (!date) return '';
//       return new Date(date).toLocaleDateString();
//     };

//     const getUploadPropertyLinks = (uploadProperty) => {
//       if (!Array.isArray(uploadProperty) || uploadProperty.length === 0) return '';
//       return uploadProperty.map(item => item.url || '').join(', ');
//     };

//     // Function to get vendor data by type
//     const getVendorByType = (vendors, type) => {
//       return vendors.find(v => v.vendorType.toLowerCase() === type.toLowerCase()) || null;
//     };

//     // Function to get vendor name from vendorModel
//     const getVendorName = async (vendorId) => {
//       if (!vendorId) return '';
//       try {
//         const vendor = await vendorModel.findById(vendorId).lean();
//         return vendor?.fullName || '';
//       } catch (error) {
//         console.error(`Error fetching vendor name for ID ${vendorId}:`, error);
//         return '';
//       }
//     };

//     // Get all vendor data
//     const vendors = externalVendorData.vendors || [];
//     const rcuVendor = getVendorByType(vendors, 'rcu');
//     const legalVendor = getVendorByType(vendors, 'legal');
//     const technicalVendor = getVendorByType(vendors, 'technical');
//     const rmVendor = getVendorByType(vendors, 'rm');

//     // Fetch all vendor names in parallel
//     const [rcuName, legalName, technicalName, rmName] = await Promise.all([
//       rcuVendor?.vendorId ? getVendorName(rcuVendor.vendorId) : '',
//       legalVendor?.vendorId ? getVendorName(legalVendor.vendorId) : '',
//       technicalVendor?.vendorId ? getVendorName(technicalVendor.vendorId) : '',
//       rmVendor?.vendorId ? getVendorName(rmVendor.vendorId) : ''
//     ]);

//     // Prepare data for Google Sheets
//     const sheetData = {
//       "FIN NO": externalVendorData.customerFinIdStr || '',
//       "CUSTOMER NAME": externalVendorData.applicantFullNameStr || '',
//       "CUSTOMER FATHER NAME": externalVendorData.applicantFatherNameStr || '',
//       "CUSTOMER MOBILE NO": externalVendorData.applicantMobileNoStr || '',
//       "INTIATED BY": externalVendorData.externalManagerNameStr || '',

//       // RCU Data
//       "RCU INTIATION DATE": formatDate(rcuVendor?.assignDate || ''),
//       "RCU INTIATED TO": rcuName,
//       "RCU TRIGGER": rcuVendor?.externalVendorRemark || '',
//       "RCU COMPLETION DATE": formatDate(rcuVendor?.vendorUploadDate || ''),
//       "RCU REPORT LINK": getUploadPropertyLinks(rcuVendor?.uploadProperty),
//       "RCU REMARKS": rcuVendor?.remarkByVendor || '',
//       "RCU STATUS": rcuVendor?.vendorStatus || '',

//       // Legal Data
//       "LEGAL INTIATION DATE": formatDate(legalVendor?.assignDate || ''),
//       "LEGAL INTIATED TO": legalName,
//       "LEGAL TRIGGER": legalVendor?.externalVendorRemark || '',
//       "LEGAL COMPLETION DATE": formatDate(legalVendor?.vendorUploadDate || ''),
//       "LEGAL REPORT LINK": getUploadPropertyLinks(legalVendor?.uploadProperty),
//       "LEGAL REMARK": legalVendor?.remarkByVendor || '',
//       "LEGAL STATUS": legalVendor?.vendorStatus || '',

//       // Technical Data
//       "TECHNICAL INTIATION DATE": formatDate(technicalVendor?.assignDate || ''),
//       "TECHNICAL INTIATED TO": technicalName,
//       "TECHNICAL TRIGGER": technicalVendor?.externalVendorRemark || '',
//       "TECHICAL COMPLETION DATE": formatDate(technicalVendor?.vendorUploadDate || ''),
//       "TECHNICAL REPORT LINK": getUploadPropertyLinks(technicalVendor?.uploadProperty),
//       "TECHNICAL REMARK": technicalVendor?.remarkByVendor || '',
//       "TECHNICAL STATUS": technicalVendor?.vendorStatus || '',

//       // RM Data
//       "RM INTIATION DATE": formatDate(rmVendor?.assignDate || ''),
//       "RM INTIATED TO": rmName,
//       "RM TRIGGER": rmVendor?.externalVendorRemark || '',
//       "RM COMPLETION DATE": formatDate(rmVendor?.vendorUploadDate || ''),
//       "RM REPORT LINK": getUploadPropertyLinks(rmVendor?.uploadProperty),
//       "RM REMARK": rmVendor?.remarkByVendor || '',
//       "RM STATUS": rmVendor?.vendorStatus || ''
//     };

//     // Convert to row format
//     const rowToUpdate = headers.map(header => sheetData[header] || '');

//     // Update or add row
//     if (existingRowIndex === -1) {
//       rows.push(rowToUpdate);
//     } else {
//       rows[existingRowIndex] = rowToUpdate;
//     }

//     // Update Google Sheet
//     await sheets.spreadsheets.values.update({
//       spreadsheetId,
//       range: `${sheetName}!A1`,
//       valueInputOption: 'RAW',
//       resource: { values: rows },
//     });

//     console.log('External vendor data saved to Google Sheets successfully');

//   } catch (error) {
//     console.error('Error updating External Vendor Google Sheet:', error);
//     throw error;
//   }
// }


async function externalVendorGoogleSheet(externalVendorDetail) {
  console.log('google sheete')
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });
  const baseUrl = process.env.BASE_URL;

  // Define the expected headers for the Google Sheet
  const headers = [
    "FIN NO", "CUSTOMER NAME", "CUSTOMER FATHER NAME", "CUSTOMER MOBILE NO",
    "INTIATED BY", "RCU INTIATION DATE", "RCU INTIATED TO", "RCU TRIGGER",
    "RCU COMPLETION DATE", "RCU REPORT LINK", "RCU REMARK", "RCU STATUS",
    "LEGAL INTIATION DATE", "LEGAL INTIATED TO", "LEGAL TRIGGER",
    "LEGAL COMPLETION DATE", "LEGAL REPORT LINK", "LEGAL REMARK", "LEGAL STATUS",
    "TECHNICAL INTIATION DATE", "TECHNICAL INTIATED TO", "TECHNICAL TRIGGER",
    "TECHICAL COMPLETION DATE", "TECHNICAL REPORT LINK", "TECHNICAL REMARK", "TECHNICAL STATUS",
    "RM INTIATION DATE", "RM INTIATED TO", "RM TRIGGER", "RM COMPLETION DATE",
    "RM REPORT LINK", "RM REMARK", "RM STATUS"
  ];

  try {
    // Get headers and initialize if necessary
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE,
      range: "EXTERNAL VENDOR!A1:AH1",
    });

    const existingHeaders = response.data.values?.[0] || [];

    if (existingHeaders.length !== headers.length || !existingHeaders.every((h, i) => h === headers[i])) {
      // Initialize headers if they are missing or misaligned
      await sheets.spreadsheets.values.update({
        spreadsheetId: process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE,
        range: "EXTERNAL VENDOR!A1",
        valueInputOption: "RAW",
        resource: {
          values: [headers]
        }
      });
    }

    // Helper function to fetch vendor name by ID
    async function getVendorNameById(vendorId) {
      try {
        const vendor = await vendorModel.findById(vendorId);
        return vendor ? vendor.fullName : "";
      } catch (error) {
        console.error(`Error fetching vendor name for ID ${vendorId}:`, error);
        return "";
      }
    }

    // Helper function to structure vendor-specific data
    // async function getVendorTypeData(type) {
    //   const vendor = externalVendorDetail.vendors.find(
    //     v => v.vendorType.toLowerCase() === type.toLowerCase()
    //   );

    async function getVendorTypeData(type) {
      // Ensure vendors array exists
      const vendors = externalVendorDetail.vendors || [];

      const vendor = vendors.find(
        v => v && v.vendorType && v.vendorType.toLowerCase() === type.toLowerCase()
      );

      const typeUpper = type.toUpperCase();
      const result = {};

      if (vendor) {
        result[`${typeUpper} INTIATION DATE`] = vendor.assignDate || '';
        result[`${typeUpper} INTIATED TO`] = await getVendorNameById(vendor.vendorId);
        result[`${typeUpper} TRIGGER`] = vendor.externalVendorRemark || '';
        result[`${typeUpper} COMPLETION DATE`] = vendor.vendorUploadDate || '';
        result[`${typeUpper} REPORT LINK`] = vendor.uploadProperty?.length > 0
          ? vendor.uploadProperty.map(doc => `${baseUrl}${doc}`).join(', ')
          : '';
        result[`${typeUpper} REMARK`] = vendor.remarkByVendor || '';
        result[`${typeUpper} STATUS`] = vendor.vendorStatus || '';
      }

      return result;
    }

    // Map basic customer data
    const basicData = {
      "FIN NO": externalVendorDetail.customerFinIdStr || '',
      "CUSTOMER NAME": externalVendorDetail.applicantFullNameStr || '',
      "CUSTOMER FATHER NAME": externalVendorDetail.applicantFatherNameStr || '',
      "CUSTOMER MOBILE NO": externalVendorDetail.applicantMobileNoStr || '',
      "INTIATED BY": externalVendorDetail.externalManagerNameStr || ''
    };

    // Collect all vendor data for the specified types
    const vendorTypes = ['RCU', 'LEGAL', 'TECHNICAL', 'RM'];
    let vendorData = {};
    for (const type of vendorTypes) {
      vendorData = { ...vendorData, ...await getVendorTypeData(type) };
    }

    // Combine all data
    const completeData = {
      ...basicData,
      ...vendorData
    };

    // Generate row data in correct header order
    const rowData = headers.map(header => completeData[header] || '');

    // Get all existing data to find the row to update
    const allDataResponse = await sheets.spreadsheets.values.get({
      spreadsheetId: process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE,
      range: "EXTERNAL VENDOR!A:Z",
    });

    const rows = allDataResponse.data.values || [];
    const finNoIndex = headers.indexOf("FIN NO");

    // Find existing row by matching "FIN NO"
    const existingRowIndex = rows.findIndex(
      row => row[finNoIndex] === externalVendorDetail.customerFinIdStr
    );

    let values;
    let range;

    if (existingRowIndex === -1) {
      // Append new row if not found
      range = `EXTERNAL VENDOR!A${rows.length + 1}`;
      values = [rowData];
    } else {
      // Update existing row
      range = `EXTERNAL VENDOR!A${existingRowIndex + 1}`;
      values = [rowData];
    }

    // Update or append data to Google Sheets
    await sheets.spreadsheets.values.update({
      spreadsheetId: process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE,
      range: range,
      valueInputOption: "RAW",
      resource: { values },
    });

    console.log('External vendor data updated successfully');
    return true;

  } catch (error) {
    console.error('Error in externalVendorGoogleSheet:', error);
    throw error;
  }
}





// Helper function to fetch vendor name by ID
async function getVendorNameById(vendorId) {
  try {
    const vendor = await vendorModel.findById(vendorId);
    return vendor ? vendor.fullName : "";
  } catch (error) {
    console.error(`Error fetching vendor name for ID ${vendorId}:`, error);
    return "";
  }
}

// Helper function to structure vendor-specific data
// async function getVendorTypeData(type) {
//   const vendor = externalVendorDetail.vendors.find(
//     v => v.vendorType.toLowerCase() === type.toLowerCase()
//   );

async function getVendorTypeData(type) {
  // Ensure vendors array exists
  const vendors = rcuData.vendors || [];

  const vendor = vendors.find(
    v => v && v.vendorType && v.vendorType.toLowerCase() === type.toLowerCase()
  );

  const typeUpper = type.toUpperCase();
  const result = {};

  if (vendor) {
    result[`${typeUpper} INTIATION DATE`] = vendor.assignDate || '';
    result[`${typeUpper} INTIATED TO`] = await getVendorNameById(vendor.vendorId);
    result[`${typeUpper} TRIGGER`] = vendor.externalVendorRemark || '';
    result[`${typeUpper} COMPLETION DATE`] = vendor.vendorUploadDate || '';
    result[`${typeUpper} REPORT LINK`] = vendor.uploadProperty?.length > 0
      ? vendor.uploadProperty.map(doc => `${baseUrl}${doc}`).join(', ')
      : '';
    result[`${typeUpper} REMARK`] = vendor.remarkBy

  }




}


// Helper function for appending headers if needed
async function appendHeadersIfNeeded(sheets, spreadsheetId, sheetName, headers, headersWritten) {
  if (headersWritten) return true;

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:Z1`,
    });

    const existingHeaders = response.data.values?.[0] || [];

    if (existingHeaders.length === 0) {
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A1`,
        valueInputOption: 'RAW',
        resource: {
          values: [headers]
        },
      });
      return true;
    }

    return true;
  } catch (error) {
    console.error('Error in appendHeadersIfNeeded:', error);
    throw error;
  }
}

// Helper function to update or append data to sheet
async function updateOrAppendToSheet(sheets, spreadsheetId, sheetName, values) {
  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A:Z`,
    });

    const existingRows = response.data.values || [];
    const finNoIndex = externalVendorHeaders.indexOf("FIN NO");

    if (finNoIndex === -1) {
      throw new Error("FIN NO header not found in the provided headers");
    }

    const finNo = values[0][finNoIndex];
    const existingRowIndex = existingRows.findIndex(
      row => row[finNoIndex] === finNo
    );

    if (existingRowIndex === -1) {
      // Append new row
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A1`,
        valueInputOption: 'RAW',
        resource: { values },
      });
    } else {
      // Update existing row
      await sheets.spreadsheets.values.update({
        spreadsheetId,
        range: `${sheetName}!A${existingRowIndex + 1}`,
        valueInputOption: 'RAW',
        resource: { values: [values[0]] },
      });
    }

    return true;
  } catch (error) {
    console.error('Error in updateOrAppendToSheet:', error);
    throw error;
  }
}

async function RcuGoogleSheetBulk(req, res) {
  try {
    const vendorType = "legal"; // Static vendor type

    // Fetch all customer IDs from externalVendorModel
    const customerIds = await externalVendorModel.find({fileStatus:'active'}).select("customerId").lean();
    if (!customerIds.length) {
      return res.status(404).json({ message: "No customer IDs found." });
    }

    // Google Sheets Auth
    const auth = new google.auth.GoogleAuth({
      credentials,
      scopes: ["https://www.googleapis.com/auth/spreadsheets"],
    });
    const authClient = await auth.getClient();
    const sheets = google.sheets({ version: "v4", auth: authClient });

    const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
    const sheetName = vendorType.toUpperCase();

    // Fetch existing sheet data
    let rows = [];
    try {
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId,
        range: `${sheetName}!A1:ZZZ`,
      });
      rows = response.data.values || [];
    } catch (error) {
      console.log("Error fetching sheet data or sheet does not exist.", error);
    }

    // Add headers if sheet is empty
    if (rows.length === 0) {
      rows.push([
        "FIN NO", "CUSTOMER NAME", "CUSTOMER FATHER NAME", "CUSTOMER MOBILE NO",
        "INTIATION DATE", "INTIATED BY", "INTIATED TO", "VENDOR STATUS",
        "TRIGGER", "REPORT LINK", "VENDOR REMARKS", "VENDOR COMPLETION DATE",
        "APPROVAL STATUS", "APPROVAL BY", "APPROVAL DATE", "APPROVAL REMARKS"
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("FIN NO");
    if (customerIdIndex === -1) throw new Error("FIN NO field not found in the sheet.");

    // Fetch all required data in parallel
    const customerDataList = await Promise.all(
      customerIds.map(({ customerId }) =>
        applicantModel.findOne({ customerId }).lean()
      )
    );



    const customerDetails = await Promise.all(
      customerIds.map(({ customerId }) =>
        customerModel.findById(customerId).lean() // `{ customerId }` hata diya
      )
    );

    const externalVendorDataList = await Promise.all(
      customerIds.map(({ customerId }) =>
        externalVendorModel.findOne({ customerId })
          .populate("creditPdId externalVendorId pdApproverEmployeeId")
          .lean()
      )
    );

    const baseUrl = "https://prod.fincooper.in";
    const newRows = [];

    for (let i = 0; i < customerIds.length; i++) {
      const customerId = customerIds[i].customerId;
      const customerData = customerDataList[i];
      const customerDataId = customerDetails[i];
      const externalVendorData = externalVendorDataList[i];

      if (!customerData || !externalVendorData) continue;

      const vendor = externalVendorData?.vendors?.find(
        v => v.vendorType?.toLowerCase() === vendorType.toLowerCase()
      );
      if (!vendor) continue; // Skip if vendor is not found

      const findVendorName = await vendorModel.findById(vendor.vendorId).lean();
      const assignedEmployee = await employeeModel.findById(vendor.assignEmployeeId).select('employeName').lean();
      const approverEmployee = await employeeModel.findById(vendor.approverEmployeeId).select('employeName').lean();

      const sheetData = {
        "FIN NO": customerDataId?.customerFinId || "",
        "CUSTOMER NAME": customerData?.fullName || "",
        "CUSTOMER FATHER NAME": customerData?.fatherName || "",
        "CUSTOMER MOBILE NO": customerData?.mobileNo || "",
        "INTIATION DATE": vendor?.assignDate || "",
        "INTIATED BY": assignedEmployee?.employeName || externalVendorData.externalVendorId?.employeName || "",
        "INTIATED TO": findVendorName?.fullName || "",
        "VENDOR STATUS": vendor?.vendorStatus || '',
        "TRIGGER": vendor?.externalVendorRemark || '',
        "REPORT LINK": vendor?.uploadProperty?.map(doc => `${baseUrl}${doc}`).join(', ') || '',
        "VENDOR REMARKS": vendor?.reason || '',
        "VENDOR COMPLETION DATE": vendor?.vendorUploadDate || '',
        "APPROVAL STATUS": vendor?.statusByVendor || '',
        "APPROVAL BY": approverEmployee?.employeName || '',
        "APPROVAL DATE": vendor?.approverDate || '',
        "APPROVAL REMARKS": vendor?.approverRemark || '',
      };

      const existingRowIndex = rows.findIndex(row => row[customerIdIndex] === sheetData["FIN NO"]);

      if (existingRowIndex === -1) {
        newRows.push(headers.map(header => sheetData[header] || ""));
      } else {
        headers.forEach((header, colIndex) => {
          rows[existingRowIndex][colIndex] = sheetData[header] || "";
        });
      }
    }

    // Append new rows if there are any
    if (newRows.length) {
      rows = rows.concat(newRows);
    }

    // Bulk update the sheet
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("Bulk data update successful!");
    return res.status(200).json({ message: "Bulk data update successful!" });

  } catch (error) {
    console.error("Error in bulk update:", error);
    return res.status(500).json({ message: "Internal server error", error: error.message });
  }
}



async function RcuGoogleSheet(customerId, vendorType) {
  let sheetNameNew = vendorType.toUpperCase();
  const customerData = await applicantModel.findOne({ customerId }).populate({ path: "customerId" }).lean()
  const externalVendorData = await externalVendorModel.findOne({ customerId }).populate({ path: "creditPdId" }).populate({ path: "externalVendorId" }).populate({ path: "pdApproverEmployeeId" }).lean()
  const vendor = externalVendorData?.vendors?.find(v => v.vendorType.toLowerCase() == vendorType.toLowerCase());
  const findVendorName = await vendorModel.findById(vendor.vendorId).lean();

  let ApprovedBy = "";
  if (vendor?.approverEmployeeId) {
    const EmployeeName = await employeeModel.findById(vendor.approverEmployeeId).select('employeName').lean();
    if (EmployeeName) {
      ApprovedBy = EmployeeName.employeName;
    }
  }

  let Employee = "";
  if (vendor?.assignEmployeeId) {
    const EmployeeName = await employeeModel.findById(vendor.assignEmployeeId).select('employeName').lean();
    if (EmployeeName) {
      Employee = EmployeeName.employeName;
    }
  }

  const baseUrl = "https://prod.fincooper.in";
  const sheetData = {
    "FIN NO": customerData?.customerId?.customerFinId,
    "CUSTOMER NAME": customerData.fullName,
    "CUSTOMER FATHER NAME": customerData.fatherName,
    "CUSTOMER MOBILE NO": customerData.mobileNo,
    "INTIATION DATE": vendor?.assignDate,
    "INTIATED BY": Employee ? Employee : externalVendorData.externalVendorId?.employeName,
    "INTIATED TO": findVendorName?.fullName || "",
    "VENDOR STATUS": vendor?.vendorStatus || '',
    "TRIGGER": vendor?.externalVendorRemark || '',
    "REPORT LINK": vendor?.uploadProperty.map(doc => `${baseUrl}${doc}`).join(', ') || '',
    "VENDOR REMARKS": vendor?.reason || '',
    "VENDOR  COMPLETION DATE": vendor?.vendorUploadDate || '',
    "APPROVAL STATUS": vendor?.statusByVendor || '',
    "APPROVAL BY": ApprovedBy || '',
    "APPROVAL DATE": vendor?.approverDate || '',
    "APPROVAL REMARKS": vendor?.approverRemark || '',
  }

  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });
console.log('sheetNameNew',sheetNameNew)
  const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
  const sheetName = `${sheetNameNew}`;

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:ZZZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "FIN NO",
        "CUSTOMER NAME",
        "CUSTOMER FATHER NAME",
        "CUSTOMER MOBILE NO",
        "INTIATION DATE",
        "INTIATED BY",
        "INTIATED TO",
        "INTIATE STATUS",
        "TRIGGER",
        "REPORT LINK",
        "VENDOR STATUS",
        "VENDOR REMARKS",
        "VENDOR  COMPLETION DATE",
        "APPROVAL STATUS ",
        "APPROVAL BY",
        "APPROVAL DATE",
        "APPROVAL REMARKS",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("FIN NO");
    console.log("customerIdIndex", customerIdIndex);
    if (customerIdIndex === -1) {
      throw new Error("FIN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === sheetData["FIN NO"]
    );

    const dataMappings = {
      "FIN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "CUSTOMER FATHER NAME": "customerFatherNameStr",
      "CUSTOMER MOBILE NO": "customerMobileNoStr",
      "INTIATED BY": "externalManagerNameStr",
      "INTIATION DATE": "externalVendorNameStr",
      "INTIATED TO": "externalVendorNameStr",
      "INTIATE STATUS": "externalVendorNameStr",
      "TRIGGER": "externalVendorNameStr",
      "REPORT LINK": "externalVendorNameStr",
      "VENDOR REMARKS": "externalVendorNameStr",
      "VENDOR COMPLETION DATE": "externalVendorNameStr",
      "APPROVAL STATUS": "externalVendorNameStr",
      "APPROVAL BY": "externalVendorNameStr",
      "APPROVAL DATE": "externalVendorNameStr",
      "APPROVAL REMARKS": "externalVendorNameStr",

    }
    if (existingRowIndex === -1) {
      const newRow = headers.map(
        (header) => sheetData[header] || ""
      );
      rows.push(newRow);
    } else {
      headers.forEach((header, colIndex) => {
        const dataKey = header;
        if (dataKey && sheetData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = sheetData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}



async function finalApprovalSheet(data) {
  console.log("customerID", data);


  // Fetch customer data
  const customerData = await customerModel
    .findById(data)
    .select("customerFinId nearestBranchId mobileNo employeId loanAmount roi tenure");

  if (!customerData) {
    console.error("Customer data not found.");
    throw new Error("Customer data not found.");
  }

  // Fetch applicant data
  const applicantData = await applicantModel
    .findOne({ customerId: data })
    .select("fullName fatherName mobileNo");


  // Fetch branch data
  const branchdata = await newBranchModel
    .findById(customerData.nearestBranchId)
    .select("name");


  // Fetch employee data
  const employData = await employeeModel
    .findById(customerData.employeId)
    .select("employeName userName reportingManagerId");
 

  // Fetch reporting manager data
  const reportingManagerData = await employeeModel
    .findById(employData.reportingManagerId)
    .select("employeName");


  // Cibil Report data //

  const cibilData = await cibilModel.findOne({ customerId: data }).lean();
  // applicantCibilReport //
  let applicantCibilReport = "";

  if(cibilData && cibilData.applicantCibilReport){
   
    let allFilePaths = cibilData.applicantCibilReport;

        // Normalize allFilePaths to always be an array
    allFilePaths = Array.isArray(allFilePaths) ? allFilePaths : [allFilePaths];
    
    // console.log('allFilePaths',allFilePaths)

    applicantCibilReport = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet

  }

  // guarantorCibilReport //

  let guarantorCibilReport = "";
  if(cibilData && cibilData.guarantorCibilReport){
    const allFilePaths = cibilData.guarantorCibilReport;
    guarantorCibilReport = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet
  }


  // coApplicantCibilReport //

  let coApplicantCibilReport = "";
  if(cibilData && cibilData.coApplicantCibilReport){
    let allFilePaths = cibilData.coApplicantCibilReport;
    allFilePaths = Array.isArray(allFilePaths) ? allFilePaths : [allFilePaths];
    coApplicantCibilReport = allFilePaths
    .map((filePath , index)=>{
      const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
      return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n')
  }




  /// find the CustomerDocument model //

  const customerDocumentData = await customerDocumentModel.findOne({ customerId:data}).lean();



  // check the Property Document //

  // Format the PROPERTY DOCUMENT links with HYPERLINK function
// Check and format the PROPERTY DOCUMENT links

// Documents //
let docs;

if (customerDocumentData && customerDocumentData.propertyDocument) {
    const allFilePaths = customerDocumentData.propertyDocument.document
        .flatMap(doc => doc.propertyDocument); // Extract all file paths from `propertyDocument` arrays

    docs = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet
}


// Family Docs //
let familyDoc;
if(customerDocumentData && customerDocumentData.incomeDocument && customerDocumentData.incomeDocument.familyCardDocument){
    const allFilePaths = customerDocumentData?.incomeDocument?.familyCardDocument.map(doc => doc);
    familyDoc = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet
}

// Utility Bill Docs //
let UtitlityBillDoc;
if(customerDocumentData && customerDocumentData?.incomeDocument?.utilityBillDocument){
    const allFilePaths = customerDocumentData.incomeDocument.utilityBillDocument;
     // Map and correct URLs directly
     UtitlityBillDoc = allFilePaths
     .map((filePath, index) => {
         // Ensure the file path starts with "/"
         const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
         return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
     })
     .join('\n'); // Use newline character for better readability in the sheet
}


// Income Docuemnt //

let incomeDoc;
if(customerDocumentData && customerDocumentData.incomeDocument && customerDocumentData.incomeDocument.incomeDocument){
    const allFilePaths = customerDocumentData.incomeDocument.incomeDocument;
    incomeDoc = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet
}


// bank statment docs // 

let bankStatementDoc;
if(customerDocumentData && customerDocumentData.incomeDocument && customerDocumentData.incomeDocument.bankStatementDocument){
    const allFilePaths = customerDocumentData.incomeDocument.bankStatementDocument;
    bankStatementDoc = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet
}

// Udyam docs //

let utilityBillDoc;
if(customerDocumentData && customerDocumentData.incomeDocument && customerDocumentData.incomeDocument.utilityBillDocument){

    const allFilePaths = customerDocumentData.incomeDocument.utilityBillDocument;
    utilityBillDoc = allFilePaths
    .map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
    })
    .join('\n'); // Use newline character for better readability in the sheet

}





// Applicante kyc docs //
const ApplicantKYC = await applicantModel.findOne({ customerId: data }).lean();

let applicantKYC = {};

// If KYC upload exists, add the keys and values to the object
if (ApplicantKYC && ApplicantKYC.kycUpload) {
  for (const [key, value] of Object.entries(ApplicantKYC.kycUpload)) {
    applicantKYC[key] = value;
  }
}

// Format URLs with the base URL
Object.keys(applicantKYC).forEach((key) => {
  if (applicantKYC[key]) {
    const correctedPath = applicantKYC[key].startsWith('/') ? applicantKYC[key] : `/${applicantKYC[key]}`;
    applicantKYC[key] = `${baseUrl}${correctedPath}`;
  }
});

const kycImageUrlsWithKeys = Object.entries(applicantKYC).map(([key, url], index) => {
  return `${key}: ${url}`; // Including the key as part of the identity mark
});

const kycImageUrlsString = kycImageUrlsWithKeys.join("\n");



// co-Applicante kyc

const co_Applicant = await coApplicantModel.findOne({ customerId: data }).lean();
// console.log("co_Applicante" ,   co_Applicant)

let coapplicant = {};

// If KYC upload exists, add the keys and values to the object
if (co_Applicant && co_Applicant.kycUpload) {
  for (const [key, value] of Object.entries(co_Applicant.kycUpload)) {
    coapplicant[key] = value;
  }
}

// Format URLs with the base URL
Object.keys(coapplicant).forEach((key) => {
  if (coapplicant[key]) {
    const correctedPath = coapplicant[key].startsWith('/') ? coapplicant[key] : `/${coapplicant[key]}`;
    coapplicant[key] = `${baseUrl}${correctedPath}`;
  }
});

// Extract only the URL values (not the keys)
const cokycImageUrlsWithKeys = Object.entries(coapplicant).map(([key, url], index) => {
  return `${key}: ${url}`; // Including the key as part of the identity mark
});

// Join the URLs as a string
const cokycImageUrlsString = cokycImageUrlsWithKeys.join("\n");






  // fetch from the pd model //

  const pdData = await pdModel.findOne({ customerId:data}).lean();

  // find pd data of pdId //

  const employeepd = await employeeModel.findById(pdData.pdId).select("employeName").lean();



  // fetch the RCU , LEGAL , TECHNICAL //

  let LEGAL_REPORT="";
  let RCU_REPORT="";
  let TECHNICAL_REPORT="";
  let RCU_STATUS = "";
  let Technical_STATUS = "";
  let Legal_STATUS = "";



  const externalVendorData = await externalVendorModel
    .findOne({ customerId: data })
    .populate({ path: "creditPdId" })
    .populate({ path: "externalVendorId" })
    .populate({ path: "pdApproverEmployeeId" })
    .lean();

  
  if (externalVendorData && externalVendorData.vendors) {
    externalVendorData.vendors.forEach((vendor) => {
      if (vendor.vendorType == "rcu") {
        RCU_STATUS = vendor.statusByVendor || "";
        RCU_REPORT = vendor.assignDocuments || "";
      } else if (vendor.vendorType == "technical") {
        Technical_STATUS = vendor.statusByVendor || "";
        TECHNICAL_REPORT = vendor.assignDocuments || "";
      } 
      else if (vendor.vendorType == "legal") {
        Legal_STATUS = vendor.statusByVendor || "";
        LEGAL_REPORT = vendor.assignDocuments || "";
      }
    });
  }




  if (RCU_REPORT || TECHNICAL_REPORT || LEGAL_REPORT) {
    if (RCU_REPORT) {
      RCU_REPORT = RCU_REPORT.map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
      }).join('\n'); // Join URLs with newline
    }
  
    if (TECHNICAL_REPORT) {
      TECHNICAL_REPORT = TECHNICAL_REPORT.map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
      }).join('\n'); // Join URLs with newline
    }
  
    if (LEGAL_REPORT) {
      LEGAL_REPORT = LEGAL_REPORT.map((filePath, index) => {
        // Ensure the file path starts with "/"
        const correctedPath = filePath.startsWith('/') ? filePath : `/${filePath}`;
        return `${index + 1}. ${baseUrl}${correctedPath}`; // Numbered URL
      }).join('\n'); // Join URLs with newline
    }
  }









  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.FINAL_APPROVAL_SHEET;
  // const spreadsheetId = "1HWpFoimuoPff--Y9UhsOFaLJV8GWpb66Td9MA-qQwCE";
  // const sheetName = "TEST_FINAL_APPROVAL";
  const sheetName = "FINAL_APPROVAL_DASHBOARD";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:ZZZ`,
    });

    let rows = response.data.values || [];

    // Add headers if the sheet is empty
    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "FILE NO",
        "BRANCH",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "SALES PERSON NAME",
        "MANAGER NAME",
        "ASSIGEND BY",
        "PARTNER NAME",
        "PD DONE BY",
        "PD DONE DATE",
        "LOAN AMOUNT",
        "ROI",
        "TENURE",
        "REMARKS",
        "RCU STATUS",
        "TECHNICAL STATUS",
        "LEGAL STATUS",
        "PARTNER SANCTION DATE",
        "PHYSICAL COURIER",
        "CHARGES",
        "ESIGN",
        "SENT TO PARTNER",
        "PROPERTY DOCUMENT",
        "INCOME DOCUMENT",
        "BANK STATEMENT",
        "UTILITY BILL AND RESI PROOF",
        "UDYAM CERTIFICATE",
        "FAMILY CARD",
        "PD REPORT",
        "TECHNICAL REPORT",
        "LEGAL REPORT (Sanction)",
        "RCU REPORT",
        "APPLICANT CIBIL REPORT",
        "CO-APPLICANT CIBIL REPORT",
        "2nd CO-APPLICANT CIBIL REPORT",
        "GUARANTOR CIBIL REPORT",
        "APPLICANT KYC  (NO SIGN , NO OSV )",
        "CO-APPLICANT KYC  (NO SIGN , NO OSV )"
      ]);
    }

    const headers = rows[0];
    const fileNoIndex = headers.indexOf("FILE NO");

    if (fileNoIndex === -1) {
      throw new Error("FILE NO field not found in the sheet.");
    }

    const branchName = branchdata ? branchdata.name : "Branch Not Found";
    const reportingManagerName =
      reportingManagerData?.employeName || "Manager Not Found";

    // Prepare data for the sheet
    const sheetData = {
      "FILE NO": customerData.customerFinId || "",
      "CUSTOMER NAME": applicantData?.fullName || "",
      "FATHER NAME": applicantData?.fatherName || "",
      "MOBILE NO": customerData.mobileNo || "",
      "BRANCH": branchName,
      "SALES PERSON NAME": employData.employeName || "",
      "MANAGER NAME": reportingManagerName,
      "ASSIGEND BY": employData.employeName || "",
      "PARTNER NAME": pdData?.partnerName || "",
      "PD DONE BY": employeepd?.employeName|| "",
      "PD DONE DATE": pdData.bdCompleteDate || "",
      "LOAN AMOUNT": customerData.loanAmount || "",
      "ROI": customerData.roi || "",
      "TENURE": customerData.tenure || "",
      "REMARKS": pdData.remarkByPd || "",
      "RCU STATUS": RCU_STATUS,
      "TECHNICAL STATUS": Technical_STATUS,
      "LEGAL STATUS": Legal_STATUS,
      "PARTNER SANCTION DATE": pdData.partnerSanctionDate || "",
      "PHYSICAL COURIER": pdData.physicalCourier || "",
      "CHARGES": pdData.charges || "",
      "ESIGN": pdData.esign || "",
      "SENT TO PARTNER": pdData.sentToPartner || "",
      "PROPERTY DOCUMENT": docs || "",  
      "INCOME DOCUMENT": incomeDoc || "",
      "BANK STATEMENT": bankStatementDoc || "",
      "UTILITY BILL AND RESI PROOF": utilityBillDoc || "",
      "UDYAM CERTIFICATE": UtitlityBillDoc || "",
      "FAMILY CARD": familyDoc || "",
      "PD REPORT": `${baseUrl}${pdData.pdfLink}` || "",
      "TECHNICAL REPORT": TECHNICAL_REPORT || "",
      "LEGAL REPORT (Sanction)": LEGAL_REPORT || "",
      "RCU REPORT": RCU_REPORT || "",
      "APPLICANT CIBIL REPORT": applicantCibilReport || "",
      "CO-APPLICANT CIBIL REPORT": coApplicantCibilReport || "",
      "2nd CO-APPLICANT CIBIL REPORT": "",
      "GUARANTOR CIBIL REPORT": guarantorCibilReport || "",
      "APPLICANT KYC  (NO SIGN , NO OSV )": kycImageUrlsString || "",
      "CO-APPLICANT KYC  (NO SIGN , NO OSV )":cokycImageUrlsString || ""
      
    };




    // Find existing row by FILE NO
    const existingRowIndex = rows.findIndex(
      (row, index) =>
        index > 0 && // Skip headers
        row[fileNoIndex] === sheetData["FILE NO"]
    );

    if (existingRowIndex === -1) {
      // Add a new row for new FILE NO
      console.log("Adding new row to the sheet.");
      const newRow = headers.map((header) => sheetData[header] || "");
      rows.push(newRow);
    } else {

      headers.forEach((header, colIndex) => {
        if (sheetData.hasOwnProperty(header)) {
          rows[existingRowIndex][colIndex] = sheetData[header] || "";
        }
      });
    }

    // Update the Google Sheet
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("Data saved to Google Sheets successfully.");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Propagate error to the calling function
  }
}






async function cibilDetailGoogleSheet(updatedCibilData, customerFinId) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const baseUrl = process.env.BASE_URL;

  // Initialize headers and flag for checking if headers are written
  let cibilHeadersWritten = false;
  const cibilHeaders = [
    "Customer Fin ID",
    "Customer ID",
    "_id",
    "Total Loans Numbers",
    "Applicant CIBIL Report",
    "Applicant CIBIL Score",
    "Applicant Total EMI Amount",
    "Applicant Total OverDue Amount",
    "Co-Applicant CIBIL Report",
    "Co-Applicant CIBIL Score",
    "Co-Applicant Total EMI Amount",
    "Co-Applicant Total OverDue Amount",
    "Guarantor CIBIL Report",
    "Guarantor CIBIL Score",
    "Guarantor Total EMI Amount",
    "Guarantor Total OverDue Amount",
    "CIBIL ID",
    "PD ID",
    "Created At",
    "Updated At",
  ];

  // Set a maximum number of loan details to handle
  const maxDetails = 10; // This can be adjusted based on your requirements

  // Flatten the cibil details into a single row with dynamic headers
  const flattenedValues = [
    customerFinId,
    updatedCibilData.customerId,
    updatedCibilData._id,
    updatedCibilData.TotalLoansNumbers,
    updatedCibilData.applicantCibilReport,
    updatedCibilData.applicantCibilScore,
    updatedCibilData.applicantTotalEmiAmount,
    updatedCibilData.applicantTotalOverDueAmount,
    updatedCibilData.coApplicantCibilReport,
    updatedCibilData.coApplicantCibilScore,
    updatedCibilData.coApplicantTotalEmiAmount,
    updatedCibilData.coApplicantTotalOverDueAmount,
    updatedCibilData.guarantorCibilReport,
    updatedCibilData.guarantorCibilScore,
    updatedCibilData.guarantorTotalEmiAmount,
    updatedCibilData.guarantorTotalOverDueAmount,
    updatedCibilData.cibilId,
    updatedCibilData.pdId,
    updatedCibilData.createdAt,
    updatedCibilData.updatedAt,
  ];

  // Ensure headers and flattened values align correctly
  for (let i = 0; i < maxDetails; i++) {
    // Add applicant details dynamically, or fill with empty values
    const applicantDetail = updatedCibilData.applicantCibilDetail[i] || {};
    flattenedValues.push(
      applicantDetail.loanType || "",
      applicantDetail.loanAmount || "",
      applicantDetail.outstandingAmount || "",
      applicantDetail.overDue || "",
      applicantDetail.emi || ""
    );
    cibilHeaders.push(
      `Applicant Loan Type-${i + 1}`,
      `Applicant Loan Amount-${i + 1}`,
      `Applicant Outstanding Amount-${i + 1}`,
      `Applicant OverDue-${i + 1}`,
      `Applicant EMI-${i + 1}`
    );

    // Add co-applicant details dynamically, or fill with empty values
    const coApplicantDetail = updatedCibilData.coApplicantCibilDetail[i] || {};
    flattenedValues.push(
      coApplicantDetail.loanType || "",
      coApplicantDetail.loanAmount || "",
      coApplicantDetail.outstandingAmount || "",
      coApplicantDetail.overDue || "",
      coApplicantDetail.emi || ""
    );
    cibilHeaders.push(
      `Co-Applicant Loan Type-${i + 1}`,
      `Co-Applicant Loan Amount-${i + 1}`,
      `Co-Applicant Outstanding Amount-${i + 1}`,
      `Co-Applicant OverDue-${i + 1}`,
      `Co-Applicant EMI-${i + 1}`
    );

    // Add guarantor details dynamically, or fill with empty values
    const guarantorDetail = updatedCibilData.guarantorCibilDetail[i] || {};
    flattenedValues.push(
      guarantorDetail.loanType || "",
      guarantorDetail.loanAmount || "",
      guarantorDetail.outstandingAmount || "",
      guarantorDetail.overDue || "",
      guarantorDetail.emi || ""
    );
    cibilHeaders.push(
      `Guarantor Loan Type-${i + 1}`,
      `Guarantor Loan Amount-${i + 1}`,
      `Guarantor Outstanding Amount-${i + 1}`,
      `Guarantor OverDue-${i + 1}`,
      `Guarantor EMI-${i + 1}`
    );
  }

  // Check if headers are already set
  const headerCheck = await sheets.spreadsheets.values.get({
    spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
    range: "CIBIL DETAIL!A1:Z1",
  });

  const existingHeaders = headerCheck.data.values
    ? headerCheck.data.values[0]
    : [];

  if (JSON.stringify(cibilHeaders) !== JSON.stringify(existingHeaders)) {
    // Write new headers if needed
    await sheets.spreadsheets.values.update({
      spreadsheetId: process.env.GOOGLE_SHEET_KEY_LIVE,
      range: "CIBIL DETAIL!A1",
      valueInputOption: "RAW",
      resource: { values: [cibilHeaders] },
    });
  }

  // Update or append the row in the sheet
  await updateOrAppendToSheet2(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "CIBIL DETAIL",
    [flattenedValues]
  );
}

async function updateOrAppendToSheet2(
  sheets,
  spreadsheetId,
  sheetName,
  values
) {
  try {
    // Fetch current data from the sheet, starting from the first row after the headers
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A2:AAX`, // Assuming columns extend to Z; adjust as needed
    });

    const rows = response.data.values || [];
    const _idToFind = values[0][2]; // The _id we want to match is in the 3rd column (index 2)

    // Find the row index with the matching '_id'
    let rowIndex = -1;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i][2] == _idToFind) {
        // Check if the _id in the current row matches
        rowIndex = i + 2; // Adjust for the header row and 0-based indexing

        break;
      }
      // console.log("sssssssssssss", i, i + 2, rows[i][2]);
    }

    const resource = { values };
    // console.log("swwww", rowIndex);
    if (rowIndex > -1) {
      // Update the existing row with the matching '_id'
      // console.log("sasgar", rowIndex);

      await sheets.spreadsheets.values.update({
        spreadsheetId,
        range: `${sheetName}!A${rowIndex}:AAX${rowIndex}`, // Update the specific row range
        valueInputOption: "RAW",
        resource,
      });
      // console.log(`Row updated at index: ${rowIndex}`);
    } else {
      // Append new row if no matching _id was found
      await sheets.spreadsheets.values.append({
        spreadsheetId,
        range: `${sheetName}!A:A`,
        valueInputOption: "RAW",
        insertDataOption: "INSERT_ROWS",
        resource,
      });
      console.log("New row appended.");
    }
  } catch (error) {
    console.error("Error updating or appending to sheet:", error);
  }
}



async function applicantGoogleSheetList(applicant) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });
  applicantHeadersWritten = await appendHeadersIfNeeded(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "APPLICANT DETAILS",
    applicantHeaders,
    applicantHeadersWritten
  );

  const baseUrl = process.env.BASE_URL;
  const values = applicant.map(updatedApplicant => [
    // const values = [
    [
      updatedApplicant?.customerId?.customerFinId ? updatedApplicant?.customerId?.customerFinId : '',
      updatedApplicant.customerId?._id ? updatedApplicant.customerId?._id : "",
      updatedApplicant.aadharNo || ' ',
      updatedApplicant.panNo || ' ',
      updatedApplicant.fullName || ' ',
      updatedApplicant.spouseName || ' ',
      updatedApplicant.fatherName || ' ',
      updatedApplicant.motherName || ' ',
      updatedApplicant.gender || ' ',
      updatedApplicant.mobileNo || ' ',
      updatedApplicant.maritalStatus || ' ',
      updatedApplicant.email || ' ',
      updatedApplicant.dob || ' ',
      updatedApplicant.religion || ' ',
      updatedApplicant.caste || ' ',
      updatedApplicant.education || ' ',
      updatedApplicant.age || ' ',
      updatedApplicant.voterIdNo || ' ',
      updatedApplicant.drivingLicenceNo || ' ',
      updatedApplicant.permanentAddress?.addressLine1 || ' ',
      updatedApplicant.permanentAddress?.addressLine2 || ' ',
      updatedApplicant.permanentAddress?.city || ' ',
      updatedApplicant.permanentAddress?.state || ' ',
      updatedApplicant.permanentAddress?.district || ' ',
      updatedApplicant.permanentAddress?.pinCode || ' ',
      updatedApplicant.localAddress?.addressLine1 || ' ',
      updatedApplicant.localAddress?.addressLine2 || ' ',
      updatedApplicant.localAddress?.city || ' ',
      updatedApplicant.localAddress?.state || ' ',
      updatedApplicant.localAddress?.district || ' ',
      updatedApplicant?.applicantPhoto
        ? `${baseUrl}${updatedApplicant.applicantPhoto}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.aadharFrontImage
        ? `${baseUrl}${updatedApplicant.kycUpload.aadharFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.aadharBackImage
        ? `${baseUrl}${updatedApplicant.kycUpload.aadharBackImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.panFrontImage
        ? `${baseUrl}${updatedApplicant.kycUpload.panFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.voterIdImage
        ? `${baseUrl}${updatedApplicant.kycUpload.voterIdImage}`
        : "Not Upload Image",
      updatedApplicant?.kycUpload?.drivingLicenceImage
        ? `${baseUrl}${updatedApplicant.kycUpload.drivingLicenceImage}`
        : "Not Upload Image",
      updatedApplicant?.ocrAadharFrontImage
        ? `${baseUrl}${updatedApplicant.ocrAadharFrontImage}`
        : "Not Upload Image",
      updatedApplicant?.ocrAadharBackImage
        ? `${baseUrl}${updatedApplicant.ocrAadharBackImage}`
        : "Not Upload Image",
      updatedApplicant.createdAt,
      updatedApplicant.updatedAt,
      updatedApplicant._id,
    ],
  ]);

  await updateOrAppendToSheet(
    sheets,
    process.env.GOOGLE_SHEET_KEY_LIVE,
    "APPLICANT DETAILS",
    values
  );
}


async function creditPdAndPdReportGoogleSheet(data) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });

  const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
  const sheetName = "CREDIT AND PD REPORT";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];
    let headers = rows[0] || [];

    // Define headers if the sheet is empty
    if (rows.length === 0) {
      headers = [
        "FIN NO", "CUSTOMER NAME", "FATHER NAME", "MOBILE NO", "INTIATION DATE", "INTIATED BY",
        "INTIATED TO", "INTIATE STATUS", "PD COMPLETE DATE", "PD BY REMARK", "APPROVED AMOUNT", "ROI", "TEMURE", "EMI"
      ];
      rows.push(headers);
    }

    const customerIdIndex = headers.indexOf('FIN NO');
    if (customerIdIndex === -1) {
      throw new Error('FIN NO field not found in the sheet.');
    }

    // Find the row with matching FIN NO
    const existingRowIndex = rows.findIndex(row => row[customerIdIndex] === data.customerFinIdStr);

    // Map data fields to sheet headers
    const dataMappings = {
      "FIN NO": ["customerFinIdStr"],
      "CUSTOMER NAME": ["applicantFullNameStr"],
      "FATHER NAME": ["applicantFatherNameStr"],
      "MOBILE NO": ["applicantMobileNoStr"],
      "INTIATION DATE": ["creditPdAssignDate"],
      "INTIATED BY": ["externalManagerNameStr"],
      "INTIATED TO": ["creditPdEmployeeName"],
      "INTIATE STATUS": ["statusByCreditPdStr"],
      "PD COMPLETE DATE": ["formCompleteDateStr"],
      "PD BY REMARK": ["remarkByPdStr"],
      "APPROVED AMOUNT": ["approveLoanDetails", "approvedAmount"],
      "ROI": ["approveLoanDetails", "ROI"],
      "TEMURE": ["approveLoanDetails", "Tenure"],
      "EMI": ["approveLoanDetails", "EMI"],
    };

    // Construct the row based on headers and dataMappings
    const rowToUpdate = headers.map(header => {
      if (dataMappings[header]) {
        let value = dataMappings[header].reduce((obj, key) => obj && obj[key], data) || '';
        return typeof value === 'object' ? JSON.stringify(value) : value;
      }
      return '';
    });

    if (existingRowIndex === -1) {
      // Insert a new row if no existing row is found
      rows.push(rowToUpdate);
    } else {
      // Update the existing row in-place
      rows[existingRowIndex] = rowToUpdate;
    }

    // Write the entire data back to the sheet
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows },
    });

    console.log('Data saved to Google Sheets successfully');

  } catch (error) {
    console.error('Error updating Google Sheet:', error);
    throw error;
  }
}


async function salesToPdAllFilesDataGoogleSheet(AllData) {

  console.log('funcions check ----')
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: 'v4', auth: authClient });

  // const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "NEW FILE MASTER";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];


    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO", "PRODUCT", "LOGIN DATE", "LOGIN TIME", "BRANCH", "EMP CODE", "EMP FINEXE ID", "SALSE PERSON NAME",
        "MANAGER NAME", "CLUSTER MANAGER NAME", "CUSTOMER NAME", "FATHER NAME", "MOBILE NO",
        "PAYMENT DATE", "PAYMENT TIME", "PAYMENT DETAIL", "RAZORPAY PAYMENT STATUS", "PAYMENT GATEWAY",
        "LOGIN FINAL STATUS", "LOGIN FINAL REMARK",
        "PD ALLOCATION", "PD STATUS", "PD REMARK", "PD DATE", "PD TIME",
        "BRANCH PENDENCY ALLOCATION", "BRANCH PENDENCY STATUS", "SANCTION STATUS", "DISBURSEMENT STATUS",
        "RCU STATUS", "TECHNICAL STATUS", "LEGAL STATUS", "RM STATUS", "TAGGING STATUS"
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf('LOAN NO');
    if (customerIdIndex === -1) {
      throw new Error('LOAN NO field not found in the sheet.');
    }

    const existingRowIndex = rows.findIndex(row => row[customerIdIndex] === AllData.customerFinIdStr);


    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "PRODUCT": "productNameStr",
      "LOGIN DATE": "leadGenedateDateStr",
      "LOGIN TIME": "leadGenedateTimeStr",
      "BRANCH": "customerBranchNameStr",
      "EMP CODE": "employeUniqueIdStr",
      "EMP FINEXE ID": "employeeUserNameStr",
      "SALSE PERSON NAME": "employeNameStr",
      "MANAGER NAME": "employeeManagerNameStr",
      "CLUSTER MANAGER NAME": "clusterManagerNameStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",

      "PAYMENT DATE": "paymentDateStr",
      "PAYMENT TIME": "paymentTimeStr",
      "PAYMENT DETAIL": "paymentDetailStr",
      "RAZORPAY PAYMENT STATUS": "paymentStatusStr",
      "PAYMENT GATEWAY": "PaymentGatewayStr",
      "LOGIN FINAL STATUS": "loginPendenyStatusStr",
      "LOGIN FINAL REMARK": "loginFinalRemarkStr",

      "PD ALLOCATION": "pdAssignEmployeeName",
      "PD STATUS": "pdStatusStr",
      "PD REMARK": "pdRemarkStr",
      "PD DATE": "pdCompleteDateStr",
      "PD TIME": "pdCompleteTimeStr",
      "BRANCH PENDENCY ALLOCATION": "branchPendencyEmployeeNameStr",
      "BRANCH PENDENCY STATUS": "branchPendencyStatusStr",
      "SANCTION STATUS": "sanctionFormsStatusStr",
      "DISBURSEMENT STATUS": "disbursementFormsStatusStr",
      "RCU STATUS": "rcuStatusStr",
      "TECHNICAL STATUS": "technicalStatusStr",
      "LEGAL STATUS": "legalStatusStr",
      "RM STATUS": "rmStatusStr",
      "TAGGING STATUS": "taggingStatusStr",
    };





    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found'
      const newRow = headers.map(header => AllData[dataMappings[header]] || '');
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || '';
        }
      });
    }



    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows },
    });

    console.log('NEW FILE MASTER data saved to Google Sheets successfully');

  } catch (error) {
    console.error('Error updating Google Sheet:', error);
    throw error; // Ensure this error is caught by the calling function
  }
}

async function addPdDataToSheet(customerId) {
  const customerData = await applicantModel.findOne({ customerId }).populate({ path: "customerId", populate: { path: "nearestBranchId" }, populate: { path: "branch" } }).lean()
  const externalVendorData = await externalVendorModel.findOne({ customerId }).populate({ path: "creditPdId" }).populate({ path: "externalVendorId" }).populate({ path: "pdApproverEmployeeId" }).lean()
  const pdDataData = await creditPdSchema.findOne({ customerId }).lean()
  const statusCheck = ["incomplete", "WIP", "complete", "pending", "notAssign", "notRequired", "rivert", "accept", "reject"]
  const approverStatusCheck = ["approve", "rejectByApprover"]
  const sheetData = {
    "FIN NO": customerData.customerId.customerFinId,
    "LOGIN DATE": customerData?.customerId?.createdAt.toISOString().split("T")[0],
    "BRANCH": customerData?.customerId?.branch?.name,
    "CUSTOMER NAME": customerData?.fullName,
    "FATHER NAME": customerData?.fatherName,
    "MOBILE NO": customerData?.mobileNo,
    "INTIATION DATE": externalVendorData?.creditPdAssignDate?.split("T")[0],
    "INTIATED BY": externalVendorData.externalVendorId?.employeName || "",
    "INTIATED TO": externalVendorData.creditPdId?.employeName || "",
    "INTIATE STATUS": ((pdDataData?.status === "approve") && externalVendorData.statusByCreditPd) ? "complete"
      : externalVendorData.statusByCreditPd.includes("approve") ? "complete"
        : externalVendorData.statusByCreditPd,
    "FINAL DICISION": pdDataData?.approveLoanDetails?.finalDecision || "",
    "PD REMARK": externalVendorData.remarkByCreditPd?externalVendorData.remarkByCreditPd:pdDataData?.remarkByPd || "",
    "PD DATE": externalVendorData?.creditPdCompleteDate?.split("T")[0] || "",
    "PD TIME": externalVendorData?.creditPdCompleteDate?.split("T")[1] || "",
    "APPROVAL STATUS": (externalVendorData.statusByCreditPd.includes("reject") || externalVendorData.statusByCreditPd.includes("rejectByApprover")) && externalVendorData?.pdApproverEmployeeId
      ? "reject": externalVendorData.statusByCreditPd,
    "APPROVAL BY": externalVendorData?.pdApproverEmployeeId?.employeName,
    "APPROVAL DATE": externalVendorData?.creditPdApprovarDate,
    "APPROVAL REMARKS": externalVendorData?.approvalRemarkCreditPd,
    "APPROVED AMOUNT": pdDataData?.approveLoanDetails?.approvedAmount,
    "ROI": pdDataData?.approveLoanDetails?.ROI,
    "TENURE": pdDataData?.approveLoanDetails?.Tenure,
    "EMI": pdDataData?.approveLoanDetails?.EMI,
    "END USE": pdDataData?.approveLoanDetails?.endUseOfLoan,
  }


  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });


  const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
  const sheetName = "NEW PD DETAIL";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "FIN NO",
        "LOGIN DATE",
        "BRANCH",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INTIATION DATE",
        "INTIATED BY",
        "INTIATED TO",
        "INTIATE STATUS",
        "PD REMARK",
        "PD DATE",
        "PD TIME",
        "APPROVAL STATUS",
        "APPROVAL BY",
        "APPROVAL DATE",
        "APPROVAL REMARKS",
        "APPROVED AMOUNT",
        "ROI",
        "TENURE",
        "EMI",
        "END USE",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("FIN NO");
    console.log("customerIdIndex", customerIdIndex);
    if (customerIdIndex === -1) {
      throw new Error("FIN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === sheetData["FIN NO"]
    );

    const dataMappings = {
      "FIN NO": "customerFinIdStr",
      PRODUCT: "productNameStr",
      "LOGIN DATE": "leadGenedateDateStr",
      "LOGIN TIME": "leadGenedateTimeStr",
      BRANCH: "customerBranchNameStr",
      "EMP CODE": "employeUniqueIdStr",
      "EMP FINEXE ID": "employeeUserNameStr",
      "SALSE PERSON NAME": "employeNameStr",
      "MANAGER NAME": "employeeManagerNameStr",
      "CLUSTER MANAGER NAME": "clusterManagerNameStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",

      "PAYMENT DATE": "paymentDateStr",
      "PAYMENT TIME": "paymentTimeStr",
      "PAYMENT DETAIL": "paymentDetailStr",
      "RAZORPAY PAYMENT STATUS": "paymentStatusStr",

      "LOGIN FINAL STATUS": "loginPendenyStatusStr",
      "LOGIN FINAL REMARK": "loginFinalRemarkStr",

      "PD ALLOCATION": "pdAssignEmployeeName",
      "PD STATUS": "pdStatusStr",
      "PD REMARK": "pdRemarkStr",
      "PD DATE": "pdCompleteDateStr",
      "PD TIME": "pdCompleteTimeStr",
      "BRANCH PENDENCY ALLOCATION": "branchPendencyEmployeeNameStr",
      "BRANCH PENDENCY STATUS": "branchPendencyStatusStr",
      "SANCTION STATUS": "sanctionFormsStatusStr",
      "DISBURSEMENT STATUS": "disbursementFormsStatusStr",
      "RCU STATUS": "rcuStatusStr",
      "TECHNICAL STATUS": "technicalStatusStr",
      "LEGAL STATUS": "legalStatusStr",
      "RM STATUS": "rmStatusStr",
      "TAGGING STATUS": "taggingStatusStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => sheetData[header] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = header;
        if (dataKey && sheetData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = sheetData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("PD Vendor data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}




async function preparePdData(customerId) {
  const customerData = await applicantModel.findOne({ customerId })
    .populate({
      path: "customerId",
      populate: { path: "branch" }
    })
    .lean();

  const externalVendorData = await externalVendorModel.findOne({ customerId })
    .populate("creditPdId")
    .populate("externalVendorId")
    .populate("pdAssignEmployeeId")
    .populate("pdApproverEmployeeId")
    .lean();

  const pdDataData = await creditPdSchema.findOne({ customerId }).lean();

  return {
    "FIN NO": customerData?.customerId?.customerFinId,
    "LOGIN DATE": customerData?.customerId?.createdAt.toISOString().split("T")[0],
    "BRANCH": customerData?.customerId?.branch?.name,
    "CUSTOMER NAME": customerData?.fullName,
    "FATHER NAME": customerData?.fatherName,
    "MOBILE NO": customerData?.mobileNo,
    "INTIATION DATE": externalVendorData?.creditPdAssignDate?.split("T")[0],
    "INTIATED BY": externalVendorData.pdAssignEmployeeId?.employeName || externalVendorData.externalVendorId?.employeName,
    "INTIATED TO": externalVendorData.creditPdId?.employeName || "",
    "INTIATE STATUS": ((pdDataData?.status === "approve") && externalVendorData.statusByCreditPd) ? "complete"
      : externalVendorData.statusByCreditPd.includes("approve") ? "complete"
        : externalVendorData.statusByCreditPd,
    "FINAL DICISION": pdDataData?.approveLoanDetails?.finalDecision || "",
    "PD REMARK": pdDataData?.remarkByPd || "",
    // "PD DATE": pdDataData?.bdCompleteDate?.split("T")[0] || "",
    // "PD TIME": pdDataData?.bdCompleteDate?.split("T")[1] || "",
"PD DATE": externalVendorData?.creditPdCompleteDate
  ? externalVendorData?.creditPdCompleteDate.split("T")[0]
  : pdDataData?.updatedAt
  ? String(pdDataData.updatedAt).split("T")[0]
  : "",
    "PD TIME": (externalVendorData?.creditPdCompleteDate)?.split("T")[1]?.split(".")[0] || "",
    "APPROVAL STATUS": externalVendorData?.pdApproverEmployeeId ? externalVendorData.statusByCreditPd : "",
    "APPROVAL BY": externalVendorData?.pdApproverEmployeeId?.employeName,
    "APPROVAL DATE": externalVendorData?.creditPdApprovarDate,
    "APPROVAL REMARKS": externalVendorData?.approvalRemarkCreditPd,
    "APPROVED AMOUNT": pdDataData?.approveLoanDetails?.approvedAmount,
    "ROI": pdDataData?.approveLoanDetails?.ROI,
    "TEMURE": pdDataData?.approveLoanDetails?.Tenure,
    "EMI": pdDataData?.approveLoanDetails?.EMI,
    "END USE": pdDataData?.approveLoanDetails?.endUseOfLoan,
  };
}

async function updateAllPdDataToSheetTest(req, res) {
  try {
    // Find all eligible records
    const externalVendors = await externalVendorModel.find({
      statusByCreditPd: {
        $in: ["incomplete", "WIP", "complete", "pending", "approve", "reject", "rivert", "accept"]
      }
    });

    if (externalVendors.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No eligible records found to update.',
      });
    }

    console.log(`Found ${externalVendors.length} records to process.`);

    // Prepare all data in parallel using Promise.all
    const allData = await Promise.all(
      externalVendors.map(vendor => preparePdData(vendor.customerId))
    );

    // Initialize Google Sheets API
    const auth = new google.auth.GoogleAuth({
      credentials,
      scopes: ["https://www.googleapis.com/auth/spreadsheets"],
    });

    const authClient = await auth.getClient();
    const sheets = google.sheets({ version: "v4", auth: authClient });
    const spreadsheetId = process.env.EXTERNAL_REPORT_SHEET_KEY_LIVE;
    const sheetName = "UPDATED PD SHEET";

    // Get existing sheet data
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];
    const headers = rows.length === 0 ? Object.keys(allData[0]) : rows[0];

    if (rows.length === 0) {
      rows.push(headers);
    }

    // Create a map of existing FIN NOs for faster lookup
    const existingFinNos = new Map(
      rows.slice(1).map((row, index) => [row[headers.indexOf("FIN NO")], index + 1])
    );

    // Prepare updates
    const updates = allData.map(data => {
      const rowData = headers.map(header => data[header] || "");
      const existingIndex = existingFinNos.get(data["FIN NO"]);

      return {
        rowData,
        existingIndex
      };
    });

    // Apply updates
    updates.forEach(({ rowData, existingIndex }) => {
      if (existingIndex !== undefined) {
        rows[existingIndex] = rowData;
      } else {
        rows.push(rowData);
      }
    });

    // Bulk update the sheet
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    res.status(200).json({
      success: true,
      message: `Successfully processed ${externalVendors.length} records in bulk.`,
    });

  } catch (error) {
    console.error('Failed to update sheet:', error);
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
}


function formatDate(date) {
  const parsedDate = new Date(date);

  // Extract the date in YYYY-MM-DD format
  const formattedDate = parsedDate.toLocaleDateString("en-CA"); // Format: YYYY-MM-DD

  // Extract the time in hh:mm AM/PM format
  const formattedTime = parsedDate.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
  });

  return { date: formattedDate, time: formattedTime };
}

async function getAllCustomersSalesToPdGoogleSheet(req, res) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });
  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "NEW FILE MASTER";

  try {
    const targetDate = new Date("2024-12-22T06:48:27.323+00:00");
    const allCustomers = await customerModel.find({
      // createdAt: { $gt: targetDate },
    });

    if (!allCustomers || allCustomers.length === 0) {
      return badRequest(res, "No customers found for the last 15 days");
    }

    // Define headers
    const headers = [
      "LOAN NO",
      "PRODUCT",
      "LOGIN DATE",
      "LOGIN TIME",
      "BRANCH",
      "EMP CODE",
      "EMP FINEXE ID",
      "SALSE PERSON NAME",
      "MANAGER NAME",
      "CLUSTER MANAGER NAME",
      "CUSTOMER NAME",
      "FATHER NAME",
      "MOBILE NO",
      "PAYMENT DATE",
      "PAYMENT TIME",
      "PAYMENT DETAIL",
      "RAZORPAY PAYMENT STATUS",
      "PAYMENT GATEWAY",
      "LOGIN FINAL STATUS",
      "LOGIN FINAL REMARK",
      "PD ALLOCATION",
      "PD STATUS",
      "PD REMARK",
      "PD DATE",
      "PD TIME",
      "BRANCH PENDENCY ALLOCATION",
      "BRANCH PENDENCY STATUS",
      "SANCTION STATUS",
      "DISBURSEMENT STATUS",
      "RCU STATUS",
      "TECHNICAL STATUS",
      "LEGAL STATUS",
      "RM STATUS",
      "TAGGING STATUS",
    ];

    // Group customers by customerFinId
    const groupedByLoanNo = allCustomers.reduce((acc, customer) => {
      const loanNo = customer.customerFinId;
      if (!acc[loanNo]) acc[loanNo] = [];
      acc[loanNo].push(customer);
      return acc;
    }, {});

    // Process CIBIL data function
    async function processCibilData(customerId) {
      try {
        const cibilData = await cibilModel.findOne({ customerId });
        if (!cibilData)
          return { loginFinalStatusStr: "", loginPendencyRemarkStr: "" };

        function determineCibilStatus(
          applicantStatus,
          coApplicantData = [],
          guarantorStatus = ""
        ) {
          const allStatuses = [
            applicantStatus,
            ...coApplicantData.map(
              (coApp) => coApp.coApplicantCibilStatus || ""
            ),
            guarantorStatus,
          ];
          if (allStatuses.includes("pending")) return "pending";
          if (allStatuses.includes("rejected")) return "rejected";
          if (allStatuses.every((status) => status === "approved"))
            return "approved";
          return "unknown";
        }

        function formatCibilRemarks(cibilData) {
          const remarks = [];
          remarks.push(
            `Applicant:- ${cibilData.applicantCibilRemark?.trim() || "No remarks available"
            }`
          );

          const coApplicants = cibilData.coApplicantData || [];
          let coApplicantRemarks = "Co-Applicant:- ";
          if (coApplicants.length === 0) {
            coApplicantRemarks += "No remarks available.";
          } else {
            coApplicantRemarks += coApplicants
              .map(
                (coApp, idx) =>
                  `${String.fromCharCode(65 + idx)}) ${coApp.coApplicantCibilRemark?.trim() ||
                  "No remarks available"
                  }`
              )
              .join(", ");
          }
          remarks.push(coApplicantRemarks);

          remarks.push(
            `Guarantor:- ${cibilData.guarantorCibilRemark?.trim() || "No remarks available"
            }`
          );
          return remarks.join("\n");
        }

        const coApplicantData = Array.isArray(cibilData.coApplicantData)
          ? cibilData.coApplicantData
          : [];
        return {
          loginFinalStatusStr: determineCibilStatus(
            cibilData.applicantCibilStatus || "",
            coApplicantData,
            cibilData.guarantorCibilStatus || ""
          ),
          loginPendencyRemarkStr: formatCibilRemarks(cibilData),
        };
      } catch (error) {
        console.error("Error processing CIBIL data:", error.message);
        return { loginFinalStatusStr: "", loginPendencyRemarkStr: "" };
      }
    }

    // Prepare all rows data
    const allRows = [headers];

    // Process each customer group
    for (const loanNo in groupedByLoanNo) {
      const customersForLoanNo = groupedByLoanNo[loanNo];

      for (const customer of customersForLoanNo) {
        // Fetch all related data in parallel
        const [
          productData,
          employeeData,
          applicantData,
          vendorData,
          cibilResult,
        ] = await Promise.all([
          productModel.findOne({ _id: customer.productId }),
          employeeModel.findOne({ _id: customer.employeId }),
          applicantModel.findOne({ customerId: customer._id }),
          externalVendorModel.findOne({ customerId: customer._id }),
          processCibilData(customer._id),
        ]);

        // Get manager and cluster manager data if employee exists
        const [employeeManager, branchData] = await Promise.all([
          employeeData
            ? employeeModel.findOne({ _id: employeeData.reportingManagerId })
            : null,
          employeeData
            ? newBranchModel.findOne({
              _id: new ObjectId(employeeData.branchId),
            })
            : null,
        ]);

        const clusterManager = employeeManager?.reportingManagerId
          ? await employeeModel.findOne({
            _id: employeeManager.reportingManagerId,
          })
          : null;

        // Process vendor data

        let pdData = {
          vendorName: "",
          status: "notAssign",
          remark: "",
          date: "",
          time: "",
        };

        let branchPendencyData = {
          employeeName: "",
          status: "notAssign",
        };

        let statusData = {
          rcu: "notAssign",
          technical: "notAssign",
          legal: "notAssign",
          rm: "notAssign",
          tagging: "notAssign",
        };

        if (vendorData) {
          // Handle PD status
          if (vendorData.statusByCreditPd) {
            // console.log('Found statusByCreditPd:', vendorData.statusByCreditPd); // Debug log

            if (vendorData.creditPdId) {
              try {
                const [vendorDetail, pdDetail] = await Promise.all([
                  vendorModel.findById(vendorData.creditPdId),
                  pdModel.findOne({
                    pdId: new ObjectId(vendorData.creditPdId),
                  }),
                ]);

                // console.log('PD Details:', { vendorDetail, pdDetail }); // Debug log

                if (pdDetail) {
                  const pdDateTime = formatDate(pdDetail.createdAt);
                  pdData = {
                    vendorName: vendorDetail?.fullName || "",
                    status: vendorData.statusByCreditPd, // Remove fallback to preserve actual status
                    remark: vendorData.remarkByCreditPd || "",
                    date: pdDateTime.date,
                    time: pdDateTime.time,
                  };
                }
              } catch (error) {
                console.error("Error processing PD details:", error);
              }
            } else {
              // Even without creditPdId, still set the status
              pdData.status = vendorData.statusByCreditPd;
              pdData.remark = vendorData.remarkByCreditPd || "";
            }
          }

          if (vendorData.branchEmployeeId) {
            try {
              const vendorDetail = await vendorModel.findById(
                vendorData.branchEmployeeId
              );
              // console.log('Branch vendor detail:', vendorDetail); // Debug log

              branchPendencyData = {
                employeeName: vendorDetail?.fullName || "",
                status: vendorData.branchStatus, // Remove the fallback to preserve actual status
              };
            } catch (error) {
              // console.error('Error fetching branch vendor:', error);
            }
          } else {
            // If no employeeId, still preserve the status
            branchPendencyData.status = vendorData.branchStatus;
          }

          // Handle vendor type statuses
          if (vendorData.vendors && Array.isArray(vendorData.vendors)) {
            // Process all vendors at once
            vendorData.vendors.forEach((vendor) => {
              if (vendor.vendorType && vendor.statusByVendor) {
                statusData[vendor.vendorType] = vendor.statusByVendor;
              }
            });
          } else if (vendorData.vendors && vendorData.vendors.vendorType) {
            // Single vendor case
            const vendorType = vendorData.vendors.vendorType;
            statusData[vendorType] =
              vendorData.vendors.statusByVendor || "notAssign";
          }
        }

        const loginDateTime = formatDate(customer.createdAt);
        const paymentDateTime =
          customer.paymentStatus === "success"
            ? formatDate(customer.updatedAt)
            : { date: "", time: "" };

        // Create row data
        const row = [
          customer.customerFinId,
          productData?.productName || "",
          loginDateTime.date,
          loginDateTime.time,
          branchData?.name || "",
          employeeData?.employeUniqueId || "",
          employeeData?.userName || "",
          employeeData?.employeName || "",
          employeeManager?.employeName || "",
          clusterManager?.employeName || "",
          applicantData?.fullName || "",
          applicantData?.fatherName || "",
          customer.mobileNo,
          paymentDateTime.date,
          paymentDateTime.time,
          customer.paymentStatus === "success" ? customer.orderId || "" : "",
          customer.paymentStatus || "",
          customer.PaymentGateway || "",
          cibilResult.loginFinalStatusStr,
          cibilResult.loginPendencyRemarkStr,
          pdData.vendorName,
          pdData.status,
          pdData.remark,
          pdData.date,
          pdData.time,
          branchPendencyData.employeeName,
          branchPendencyData.status,
          "", // SANCTION STATUS
          "", // DISBURSEMENT STATUS
          statusData.rcu,
          statusData.technical,
          statusData.legal,
          statusData.rm,
          statusData.tagging,
        ];

        allRows.push(row);
      }
    }

    // Write all data to Google Sheets in a single operation
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1:AH${allRows.length}`,
      valueInputOption: "RAW",
      resource: { values: allRows },
    });

    return success(
      res,
      "Customer data has been successfully saved to Google Sheets."
    );
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    return unknownError(res, error);
  }
}

async function rcuDataGoogleSheet(AllData) {
  // console.log('image url', `${process.env.BASE_URL}${AllData.vendorUploadPropertyStr}`)

  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "RCU FILES DATA";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INITIATE TO",
        "INITIATE BY",
        "ASSIGN REMARK",
        "ASSIGN DATE",
        "RCU STATUS",
        "RCU UPLOAD DOC",
        "RCU VENDOR STATUS",
        "RCU COMPLETE DATE",
        "REASON",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("LOAN NO");

    if (customerIdIndex === -1) {
      throw new Error("LOAN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === AllData.customerFinIdStr
    );

    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",
      "INITIATE TO": "vendorNameStr",
      "INITIATE BY": "externalManagerNameStr",
      "ASSIGN REMARK": "fileAssignRemarkStr",
      "ASSIGN DATE": "vendorAssignDateStr",
      "RCU STATUS": "vendorStatusStr",
      "RCU UPLOAD DOC": "vendorUploadPropertyStr",
      "RCU VENDOR STATUS": "vendorFormStatusStr",
      "RCU COMPLETE DATE": "vendorCompleteDateStr",
      REASON: "reasonStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => AllData[dataMappings[header]] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("RCU data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}

async function taggingDataGoogleSheet(AllData) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "TAGGING FILES DATA";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INITIATE TO",
        "INITIATE BY",
        "ASSIGN REMARK",
        "ASSIGN DATE",
        "TAGGING STATUS",
        "TAGGING UPLOAD DOC",
        "TAGGING VENDOR STATUS",
        "TAGGING COMPLETE DATE",
        "REASON",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("LOAN NO");

    if (customerIdIndex === -1) {
      throw new Error("LOAN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === AllData.customerFinIdStr
    );

    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",
      "INITIATE TO": "vendorNameStr",
      "INITIATE BY": "externalManagerNameStr",
      "ASSIGN REMARK": "fileAssignRemarkStr",
      "ASSIGN DATE": "vendorAssignDateStr",
      "TAGGING STATUS": "vendorStatusStr",
      "TAGGING UPLOAD DOC": "vendorUploadPropertyStr",
      "TAGGING VENDOR STATUS": "vendorFormStatusStr",
      "TAGGING COMPLETE DATE": "vendorCompleteDateStr",
      REASON: "reasonStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => AllData[dataMappings[header]] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("TAGGING data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}

async function rmDataGoogleSheet(AllData) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "RM FILES DATA";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INITIATE TO",
        "INITIATE BY",
        "ASSIGN REMARK",
        "ASSIGN DATE",
        "RM STATUS",
        "RM UPLOAD DOC",
        "RM VENDOR STATUS",
        "RM COMPLETE DATE",
        "REASON",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("LOAN NO");

    if (customerIdIndex === -1) {
      throw new Error("LOAN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === AllData.customerFinIdStr
    );

    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",
      "INITIATE TO": "vendorNameStr",
      "INITIATE BY": "externalManagerNameStr",
      "ASSIGN REMARK": "fileAssignRemarkStr",
      "ASSIGN DATE": "vendorAssignDateStr",
      "RM STATUS": "vendorStatusStr",
      "RM UPLOAD DOC": "vendorUploadPropertyStr",
      "RM VENDOR STATUS": "vendorFormStatusStr",
      "RM COMPLETE DATE": "vendorCompleteDateStr",
      REASON: "reasonStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => AllData[dataMappings[header]] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("RM data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}

async function technicalDataGoogleSheet(AllData) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "TECHNICAL FILES DATA";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INITIATE TO",
        "INITIATE BY",
        "ASSIGN REMARK",
        "ASSIGN DATE",
        "TECHNICAL STATUS",
        "TECHNICAL UPLOAD DOC",
        "TECHNICAL VENDOR STATUS",
        "TECHNICAL COMPLETE DATE",
        "REASON",
        "AREA OF LAND",
        "AREA OF CONSTRUCTION",
        "FAIR MARKET VALUE",
        "RECEIVER NAME",
        "NUMBER OF CATTLE",
        "CATTLE BREED",
        "MILK LITERS PER DAY",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("LOAN NO");

    if (customerIdIndex === -1) {
      throw new Error("LOAN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === AllData.customerFinIdStr
    );

    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",
      "INITIATE TO": "vendorNameStr",
      "INITIATE BY": "externalManagerNameStr",
      "ASSIGN REMARK": "fileAssignRemarkStr",
      "ASSIGN DATE": "vendorAssignDateStr",
      "TECHNICAL STATUS": "vendorStatusStr",
      "TECHNICAL UPLOAD DOC": "vendorUploadPropertyStr",
      "TECHNICAL VENDOR STATUS": "vendorFormStatusStr",
      "TECHNICAL COMPLETE DATE": "vendorCompleteDateStr",
      REASON: "reasonStr",
      "AREA OF LAND": "areaOfLandStr",
      "AREA OF CONSTRUCTION": "areaOfConstructionStr",
      "FAIR MARKET VALUE": "fairMarketValueStr",
      "RECEIVER NAME": "receiverNameStr",
      "NUMBER OF CATTLE": "numberOfCattleStr",
      "CATTLE BREED": "cattlesBreedStr",
      "MILK LITERS PER DAY": "milkLitPerDayStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => AllData[dataMappings[header]] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("TECHNICAL data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}

async function legalDataGoogleSheet(AllData) {
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });

  const authClient = await auth.getClient();
  const sheets = google.sheets({ version: "v4", auth: authClient });

  const spreadsheetId = process.env.GOOGLE_SHEET_KEY_LIVE;
  const sheetName = "LEGAL FILES DATA";

  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${sheetName}!A1:EZ`,
    });

    let rows = response.data.values || [];

    if (rows.length === 0) {
      console.log("Sheet is empty, adding headers.");
      rows.push([
        "LOAN NO",
        "CUSTOMER NAME",
        "FATHER NAME",
        "MOBILE NO",
        "INITIATE TO",
        "INITIATE BY",
        "ASSIGN REMARK",
        "ASSIGN DATE",
        "LEGAL STATUS",
        "LEGAL UPLOAD DOC",
        "LEGAL VENDOR STATUS",
        "LEGAL COMPLETE DATE",
        "REASON",
      ]);
    }

    const headers = rows[0];
    const customerIdIndex = headers.indexOf("LOAN NO");

    if (customerIdIndex === -1) {
      throw new Error("LOAN NO field not found in the sheet.");
    }

    const existingRowIndex = rows.findIndex(
      (row) => row[customerIdIndex] === AllData.customerFinIdStr
    );

    const dataMappings = {
      "LOAN NO": "customerFinIdStr",
      "CUSTOMER NAME": "customerFullNameStr",
      "FATHER NAME": "customerFatherNameStr",
      "MOBILE NO": "customerMobileNoStr",
      "INITIATE TO": "vendorNameStr",
      "INITIATE BY": "externalManagerNameStr",
      "ASSIGN REMARK": "fileAssignRemarkStr",
      "ASSIGN DATE": "vendorAssignDateStr",
      "LEGAL STATUS": "vendorStatusStr",
      "LEGAL UPLOAD DOC": "vendorUploadPropertyStr",
      "LEGAL VENDOR STATUS": "vendorFormStatusStr",
      "LEGAL COMPLETE DATE": "vendorCompleteDateStr",
      REASON: "reasonStr",
    };

    if (existingRowIndex === -1) {
      // Create a new row if customerFinIdStr is not found
      const newRow = headers.map(
        (header) => AllData[dataMappings[header]] || ""
      );
      rows.push(newRow);
    } else {
      // Update only provided fields in the existing row
      headers.forEach((header, colIndex) => {
        const dataKey = dataMappings[header];
        if (dataKey && AllData.hasOwnProperty(dataKey)) {
          rows[existingRowIndex][colIndex] = AllData[dataKey] || "";
        }
      });
    }

    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1`,
      valueInputOption: "RAW",
      resource: { values: rows },
    });

    console.log("LEGAL data saved to Google Sheets successfully");
  } catch (error) {
    console.error("Error updating Google Sheet:", error);
    throw error; // Ensure this error is caught by the calling function
  }
}

module.exports = {
  customerGoogleSheet,
  customerGoogleSheetList,
  applicantGoogleSheet,
  coApplicantGoogleSheet,
  guarantorGoogleSheet,
  referenceGoogleSheet,
  bankDetailGoogleSheet,
  salesCaseDetailGoogleSheet,
  cibilDetailGoogleSheet,
  creditAndPdGoogleSheet,
  externalVendorGoogleSheet,
  // externalVendorGoogleSheet2,
  leadGenerateGoogleSheet,
  leadGenerateGoogleSheetListBatch,
  applicantGoogleSheetList,
  creditPdAndPdReportGoogleSheet,
  addPdDataToSheet,
  // branchPendencyGoogleSheet
  salesToPdAllFilesDataGoogleSheet,
  getAllCustomersSalesToPdGoogleSheet,
  rcuDataGoogleSheet,
  taggingDataGoogleSheet,
  rmDataGoogleSheet,
  technicalDataGoogleSheet,
  legalDataGoogleSheet,
  RcuGoogleSheet,
  RcuGoogleSheetBulk,
  updateAllPdDataToSheetTest,
  finalApprovalSheet
};

